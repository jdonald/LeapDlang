/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.10
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

module Leap;

static import Leap_im;
static import core.stdc.config;

static import std.conv;
static import std.string;

static import std.conv;
static import std.string;


float PI() @property {
  auto ret = Leap_im.PI_get();
  return ret;
}

float DEG_TO_RAD() @property {
  auto ret = Leap_im.DEG_TO_RAD_get();
  return ret;
}

float RAD_TO_DEG() @property {
  auto ret = Leap_im.RAD_TO_DEG_get();
  return ret;
}

float EPSILON() @property {
  auto ret = Leap_im.EPSILON_get();
  return ret;
}

class Vector {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Vector(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public this() {
    this(Leap_im.new_Vector__SWIG_0(), true);
  }

  public this(float _x, float _y, float _z) {
    this(Leap_im.new_Vector__SWIG_1(_x, _y, _z), true);
  }

  public this(Vector vector) {
    this(Leap_im.new_Vector__SWIG_2(Vector.swigGetCPtr(vector)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public static Vector zero() {
    Vector ret = new Vector(Leap_im.Vector_zero(), false);
    return ret;
  }

  public static Vector xAxis() {
    Vector ret = new Vector(Leap_im.Vector_xAxis(), false);
    return ret;
  }

  public static Vector yAxis() {
    Vector ret = new Vector(Leap_im.Vector_yAxis(), false);
    return ret;
  }

  public static Vector zAxis() {
    Vector ret = new Vector(Leap_im.Vector_zAxis(), false);
    return ret;
  }

  public static Vector left() {
    Vector ret = new Vector(Leap_im.Vector_left(), false);
    return ret;
  }

  public static Vector right() {
    Vector ret = new Vector(Leap_im.Vector_right(), false);
    return ret;
  }

  public static Vector down() {
    Vector ret = new Vector(Leap_im.Vector_down(), false);
    return ret;
  }

  public static Vector up() {
    Vector ret = new Vector(Leap_im.Vector_up(), false);
    return ret;
  }

  public static Vector forward() {
    Vector ret = new Vector(Leap_im.Vector_forward(), false);
    return ret;
  }

  public static Vector backward() {
    Vector ret = new Vector(Leap_im.Vector_backward(), false);
    return ret;
  }

  public float magnitude() const {
    auto ret = Leap_im.Vector_magnitude(cast(void*)swigCPtr);
    return ret;
  }

  public float magnitudeSquared() const {
    auto ret = Leap_im.Vector_magnitudeSquared(cast(void*)swigCPtr);
    return ret;
  }

  public float distanceTo(Vector other) const {
    auto ret = Leap_im.Vector_distanceTo(cast(void*)swigCPtr, Vector.swigGetCPtr(other));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float angleTo(Vector other) const {
    auto ret = Leap_im.Vector_angleTo(cast(void*)swigCPtr, Vector.swigGetCPtr(other));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float pitch() const {
    auto ret = Leap_im.Vector_pitch(cast(void*)swigCPtr);
    return ret;
  }

  public float yaw() const {
    auto ret = Leap_im.Vector_yaw(cast(void*)swigCPtr);
    return ret;
  }

  public float roll() const {
    auto ret = Leap_im.Vector_roll(cast(void*)swigCPtr);
    return ret;
  }

  public float dot(Vector other) const {
    auto ret = Leap_im.Vector_dot(cast(void*)swigCPtr, Vector.swigGetCPtr(other));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector cross(Vector other) const {
    Vector ret = new Vector(Leap_im.Vector_cross(cast(void*)swigCPtr, Vector.swigGetCPtr(other)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector normalized() const {
    Vector ret = new Vector(Leap_im.Vector_normalized(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector swigOpNeg() const {
    Vector ret = new Vector(Leap_im.Vector_swigOpNeg(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector swigOpAdd(Vector other) const {
    Vector ret = new Vector(Leap_im.Vector_swigOpAdd(cast(void*)swigCPtr, Vector.swigGetCPtr(other)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector swigOpSub(Vector other) const {
    Vector ret = new Vector(Leap_im.Vector_swigOpSub(cast(void*)swigCPtr, Vector.swigGetCPtr(other)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector swigOpMul(float scalar) const {
    Vector ret = new Vector(Leap_im.Vector_swigOpMul(cast(void*)swigCPtr, scalar), true);
    return ret;
  }

  public Vector swigOpDiv(float scalar) const {
    Vector ret = new Vector(Leap_im.Vector_swigOpDiv(cast(void*)swigCPtr, scalar), true);
    return ret;
  }

  public Vector swigOpAddAssign(Vector other) {
    Vector ret = new Vector(Leap_im.Vector_swigOpAddAssign(cast(void*)swigCPtr, Vector.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector swigOpSubAssign(Vector other) {
    Vector ret = new Vector(Leap_im.Vector_swigOpSubAssign(cast(void*)swigCPtr, Vector.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector swigOpMulAssign(float scalar) {
    Vector ret = new Vector(Leap_im.Vector_swigOpMulAssign(cast(void*)swigCPtr, scalar), false);
    return ret;
  }

  public Vector swigOpDivAssign(float scalar) {
    Vector ret = new Vector(Leap_im.Vector_swigOpDivAssign(cast(void*)swigCPtr, scalar), false);
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Vector_toString(cast(void*)swigCPtr));
    return ret;
  }

  public bool swigOpEquals(Vector other) const {
    bool ret = Leap_im.Vector_swigOpEquals(cast(void*)swigCPtr, Vector.swigGetCPtr(other)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Vector_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public float opIndex(uint index) const {
    auto ret = Leap_im.Vector_opIndex(cast(void*)swigCPtr, index);
    return ret;
  }

  public float* toFloatPointer() const {
    auto ret = cast(float*)Leap_im.Vector_toFloatPointer(cast(void*)swigCPtr);
    return ret;
  }

  public void x(float value) @property {
    Leap_im.Vector_x_set(cast(void*)swigCPtr, value);
  }

  public float x() @property const {
    auto ret = Leap_im.Vector_x_get(cast(void*)swigCPtr);
    return ret;
  }

  public void y(float value) @property {
    Leap_im.Vector_y_set(cast(void*)swigCPtr, value);
  }

  public float y() @property const {
    auto ret = Leap_im.Vector_y_get(cast(void*)swigCPtr);
    return ret;
  }

  public void z(float value) @property {
    Leap_im.Vector_z_set(cast(void*)swigCPtr, value);
  }

  public float z() @property const {
    auto ret = Leap_im.Vector_z_get(cast(void*)swigCPtr);
    return ret;
  }
}

class FloatArray {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_FloatArray(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public float* opIndex(uint index) {
    auto ret = cast(float*)Leap_im.FloatArray_opIndex(cast(void*)swigCPtr, index);
    return ret;
  }

  public void m_array(SWIGTYPE_p_float value) @property {
    Leap_im.FloatArray_m_array_set(cast(void*)swigCPtr, SWIGTYPE_p_float.swigGetCPtr(value));
  }

  public SWIGTYPE_p_float m_array() @property const {
    void* cPtr = Leap_im.FloatArray_m_array_get(cast(void*)swigCPtr);
    SWIGTYPE_p_float ret = (cPtr is null) ? null : new SWIGTYPE_p_float(cPtr, false);
    return ret;
  }

  public this() {
    this(Leap_im.new_FloatArray(), true);
  }
}

class Matrix {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Matrix(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public this() {
    this(Leap_im.new_Matrix__SWIG_0(), true);
  }

  public this(Matrix other) {
    this(Leap_im.new_Matrix__SWIG_1(Matrix.swigGetCPtr(other)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public this(Vector _xBasis, Vector _yBasis, Vector _zBasis) {
    this(Leap_im.new_Matrix__SWIG_2(Vector.swigGetCPtr(_xBasis), Vector.swigGetCPtr(_yBasis), Vector.swigGetCPtr(_zBasis)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public this(Vector _xBasis, Vector _yBasis, Vector _zBasis, Vector _origin) {
    this(Leap_im.new_Matrix__SWIG_3(Vector.swigGetCPtr(_xBasis), Vector.swigGetCPtr(_yBasis), Vector.swigGetCPtr(_zBasis), Vector.swigGetCPtr(_origin)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public this(Vector axis, float angleRadians) {
    this(Leap_im.new_Matrix__SWIG_4(Vector.swigGetCPtr(axis), angleRadians), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public this(Vector axis, float angleRadians, Vector translation) {
    this(Leap_im.new_Matrix__SWIG_5(Vector.swigGetCPtr(axis), angleRadians, Vector.swigGetCPtr(translation)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public static Matrix identity() {
    Matrix ret = new Matrix(Leap_im.Matrix_identity(), false);
    return ret;
  }

  public void setRotation(Vector axis, float angleRadians) {
    Leap_im.Matrix_setRotation(cast(void*)swigCPtr, Vector.swigGetCPtr(axis), angleRadians);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public Vector transformPoint(Vector arg0) const {
    Vector ret = new Vector(Leap_im.Matrix_transformPoint(cast(void*)swigCPtr, Vector.swigGetCPtr(arg0)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector transformDirection(Vector arg0) const {
    Vector ret = new Vector(Leap_im.Matrix_transformDirection(cast(void*)swigCPtr, Vector.swigGetCPtr(arg0)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Matrix rigidInverse() const {
    Matrix ret = new Matrix(Leap_im.Matrix_rigidInverse(cast(void*)swigCPtr), true);
    return ret;
  }

  public Matrix swigOpMul(Matrix other) const {
    Matrix ret = new Matrix(Leap_im.Matrix_swigOpMul(cast(void*)swigCPtr, Matrix.swigGetCPtr(other)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Matrix swigOpMulAssign(Matrix other) {
    Matrix ret = new Matrix(Leap_im.Matrix_swigOpMulAssign(cast(void*)swigCPtr, Matrix.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool swigOpEquals(Matrix other) const {
    bool ret = Leap_im.Matrix_swigOpEquals(cast(void*)swigCPtr, Matrix.swigGetCPtr(other)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public FloatArray toArray3x3() const {
    FloatArray ret = new FloatArray(Leap_im.Matrix_toArray3x3(cast(void*)swigCPtr), true);
    return ret;
  }

  public FloatArray toArray4x4() const {
    FloatArray ret = new FloatArray(Leap_im.Matrix_toArray4x4(cast(void*)swigCPtr), true);
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Matrix_toString(cast(void*)swigCPtr));
    return ret;
  }

  public void xBasis(Vector value) @property {
    Leap_im.Matrix_xBasis_set(cast(void*)swigCPtr, Vector.swigGetCPtr(value));
  }

  public Vector xBasis() @property const {
    void* cPtr = Leap_im.Matrix_xBasis_get(cast(void*)swigCPtr);
    Vector ret = (cPtr is null) ? null : new Vector(cPtr, false);
    return ret;
  }

  public void yBasis(Vector value) @property {
    Leap_im.Matrix_yBasis_set(cast(void*)swigCPtr, Vector.swigGetCPtr(value));
  }

  public Vector yBasis() @property const {
    void* cPtr = Leap_im.Matrix_yBasis_get(cast(void*)swigCPtr);
    Vector ret = (cPtr is null) ? null : new Vector(cPtr, false);
    return ret;
  }

  public void zBasis(Vector value) @property {
    Leap_im.Matrix_zBasis_set(cast(void*)swigCPtr, Vector.swigGetCPtr(value));
  }

  public Vector zBasis() @property const {
    void* cPtr = Leap_im.Matrix_zBasis_get(cast(void*)swigCPtr);
    Vector ret = (cPtr is null) ? null : new Vector(cPtr, false);
    return ret;
  }

  public void origin(Vector value) @property {
    Leap_im.Matrix_origin_set(cast(void*)swigCPtr, Vector.swigGetCPtr(value));
  }

  public Vector origin() @property const {
    void* cPtr = Leap_im.Matrix_origin_get(cast(void*)swigCPtr);
    Vector ret = (cPtr is null) ? null : new Vector(cPtr, false);
    return ret;
  }
}

class Interface {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          throw new object.Exception("C++ destructor does not have public access");
        }
        swigCPtr = null;
      }
    }
  }
}

class Pointable : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Pointable_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Pointable(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum Zone {
    ZONE_NONE = 0,
    ZONE_HOVERING = 1,
    ZONE_TOUCHING = 2
  }

  public this() {
    this(Leap_im.new_Pointable(), true);
  }

  public int id() const {
    auto ret = Leap_im.Pointable_id(cast(void*)swigCPtr);
    return ret;
  }

  public Frame frame() const {
    Frame ret = new Frame(Leap_im.Pointable_frame(cast(void*)swigCPtr), true);
    return ret;
  }

  public Hand hand() const {
    Hand ret = new Hand(Leap_im.Pointable_hand(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector tipPosition() const {
    Vector ret = new Vector(Leap_im.Pointable_tipPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector tipVelocity() const {
    Vector ret = new Vector(Leap_im.Pointable_tipVelocity(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector direction() const {
    Vector ret = new Vector(Leap_im.Pointable_direction(cast(void*)swigCPtr), true);
    return ret;
  }

  public float width() const {
    auto ret = Leap_im.Pointable_width(cast(void*)swigCPtr);
    return ret;
  }

  public float length() const {
    auto ret = Leap_im.Pointable_length(cast(void*)swigCPtr);
    return ret;
  }

  public bool isFinger() const {
    bool ret = Leap_im.Pointable_isFinger(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isTool() const {
    bool ret = Leap_im.Pointable_isTool(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isExtended() const {
    bool ret = Leap_im.Pointable_isExtended(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Pointable_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Pointable.Zone touchZone() const {
    Pointable.Zone ret = cast(Pointable.Zone)Leap_im.Pointable_touchZone(cast(void*)swigCPtr);
    return ret;
  }

  public float touchDistance() const {
    auto ret = Leap_im.Pointable_touchDistance(cast(void*)swigCPtr);
    return ret;
  }

  public Vector stabilizedTipPosition() const {
    Vector ret = new Vector(Leap_im.Pointable_stabilizedTipPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public float timeVisible() const {
    auto ret = Leap_im.Pointable_timeVisible(cast(void*)swigCPtr);
    return ret;
  }

  public static Pointable invalid() {
    Pointable ret = new Pointable(Leap_im.Pointable_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Pointable arg0) const {
    bool ret = Leap_im.Pointable_swigOpEquals(cast(void*)swigCPtr, Pointable.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Pointable_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Arm : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Arm_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Arm(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_Arm(), true);
  }

  public float width() const {
    auto ret = Leap_im.Arm_width(cast(void*)swigCPtr);
    return ret;
  }

  public Vector direction() const {
    Vector ret = new Vector(Leap_im.Arm_direction(cast(void*)swigCPtr), true);
    return ret;
  }

  public Matrix basis() const {
    Matrix ret = new Matrix(Leap_im.Arm_basis(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector elbowPosition() const {
    Vector ret = new Vector(Leap_im.Arm_elbowPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector wristPosition() const {
    Vector ret = new Vector(Leap_im.Arm_wristPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector center() const {
    Vector ret = new Vector(Leap_im.Arm_center(cast(void*)swigCPtr), true);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Arm_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Arm invalid() {
    Arm ret = new Arm(Leap_im.Arm_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Arm arg0) const {
    bool ret = Leap_im.Arm_swigOpEquals(cast(void*)swigCPtr, Arm.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Arm_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Bone : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Bone_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Bone(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum Type {
    TYPE_METACARPAL = 0,
    TYPE_PROXIMAL = 1,
    TYPE_INTERMEDIATE = 2,
    TYPE_DISTAL = 3
  }

  public this() {
    this(Leap_im.new_Bone(), true);
  }

  public Vector prevJoint() const {
    Vector ret = new Vector(Leap_im.Bone_prevJoint(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector nextJoint() const {
    Vector ret = new Vector(Leap_im.Bone_nextJoint(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector center() const {
    Vector ret = new Vector(Leap_im.Bone_center(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector direction() const {
    Vector ret = new Vector(Leap_im.Bone_direction(cast(void*)swigCPtr), true);
    return ret;
  }

  public float length() const {
    auto ret = Leap_im.Bone_length(cast(void*)swigCPtr);
    return ret;
  }

  public float width() const {
    auto ret = Leap_im.Bone_width(cast(void*)swigCPtr);
    return ret;
  }

  public Bone.Type type() const {
    Bone.Type ret = cast(Bone.Type)Leap_im.Bone_type(cast(void*)swigCPtr);
    return ret;
  }

  public Matrix basis() const {
    Matrix ret = new Matrix(Leap_im.Bone_basis(cast(void*)swigCPtr), true);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Bone_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Bone invalid() {
    Bone ret = new Bone(Leap_im.Bone_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Bone arg0) const {
    bool ret = Leap_im.Bone_swigOpEquals(cast(void*)swigCPtr, Bone.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Bone_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Finger : Pointable {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Finger_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Finger(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum Joint {
    JOINT_MCP = 0,
    JOINT_PIP = 1,
    JOINT_DIP = 2,
    JOINT_TIP = 3
  }

  enum Type {
    TYPE_THUMB = 0,
    TYPE_INDEX = 1,
    TYPE_MIDDLE = 2,
    TYPE_RING = 3,
    TYPE_PINKY = 4
  }

  public this() {
    this(Leap_im.new_Finger__SWIG_0(), true);
  }

  public this(Pointable arg0) {
    this(Leap_im.new_Finger__SWIG_1(Pointable.swigGetCPtr(arg0)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public Vector jointPosition(Finger.Joint jointIx) const {
    Vector ret = new Vector(Leap_im.Finger_jointPosition(cast(void*)swigCPtr, cast(int)jointIx), true);
    return ret;
  }

  public Bone bone(Bone.Type boneIx) const {
    Bone ret = new Bone(Leap_im.Finger_bone(cast(void*)swigCPtr, cast(int)boneIx), true);
    return ret;
  }

  public Finger.Type type() const {
    Finger.Type ret = cast(Finger.Type)Leap_im.Finger_type(cast(void*)swigCPtr);
    return ret;
  }

  public static Finger invalid() {
    Finger ret = new Finger(Leap_im.Finger_invalid(), false);
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Finger_toString(cast(void*)swigCPtr));
    return ret;
  }

  alias Pointable.toString toString;
}

class Tool : Pointable {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Tool_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Tool(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_Tool__SWIG_0(), true);
  }

  public this(Pointable arg0) {
    this(Leap_im.new_Tool__SWIG_1(Pointable.swigGetCPtr(arg0)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public static Tool invalid() {
    Tool ret = new Tool(Leap_im.Tool_invalid(), false);
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Tool_toString(cast(void*)swigCPtr));
    return ret;
  }

  alias Pointable.toString toString;
}

class Hand : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Hand_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Hand(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_Hand(), true);
  }

  public int id() const {
    auto ret = Leap_im.Hand_id(cast(void*)swigCPtr);
    return ret;
  }

  public Frame frame() const {
    Frame ret = new Frame(Leap_im.Hand_frame(cast(void*)swigCPtr), true);
    return ret;
  }

  public PointableList pointables() const {
    PointableList ret = new PointableList(Leap_im.Hand_pointables(cast(void*)swigCPtr), true);
    return ret;
  }

  public Pointable pointable(int id) const {
    Pointable ret = new Pointable(Leap_im.Hand_pointable(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public FingerList fingers() const {
    FingerList ret = new FingerList(Leap_im.Hand_fingers(cast(void*)swigCPtr), true);
    return ret;
  }

  public Finger finger(int id) const {
    Finger ret = new Finger(Leap_im.Hand_finger(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public ToolList tools() const {
    ToolList ret = new ToolList(Leap_im.Hand_tools(cast(void*)swigCPtr), true);
    return ret;
  }

  public Tool tool(int id) const {
    Tool ret = new Tool(Leap_im.Hand_tool(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public Vector palmPosition() const {
    Vector ret = new Vector(Leap_im.Hand_palmPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector stabilizedPalmPosition() const {
    Vector ret = new Vector(Leap_im.Hand_stabilizedPalmPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector palmVelocity() const {
    Vector ret = new Vector(Leap_im.Hand_palmVelocity(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector palmNormal() const {
    Vector ret = new Vector(Leap_im.Hand_palmNormal(cast(void*)swigCPtr), true);
    return ret;
  }

  public float palmWidth() const {
    auto ret = Leap_im.Hand_palmWidth(cast(void*)swigCPtr);
    return ret;
  }

  public Vector direction() const {
    Vector ret = new Vector(Leap_im.Hand_direction(cast(void*)swigCPtr), true);
    return ret;
  }

  public Matrix basis() const {
    Matrix ret = new Matrix(Leap_im.Hand_basis(cast(void*)swigCPtr), true);
    return ret;
  }

  public Arm arm() const {
    Arm ret = new Arm(Leap_im.Hand_arm(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector wristPosition() const {
    Vector ret = new Vector(Leap_im.Hand_wristPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector sphereCenter() const {
    Vector ret = new Vector(Leap_im.Hand_sphereCenter(cast(void*)swigCPtr), true);
    return ret;
  }

  public float sphereRadius() const {
    auto ret = Leap_im.Hand_sphereRadius(cast(void*)swigCPtr);
    return ret;
  }

  public float pinchStrength() const {
    auto ret = Leap_im.Hand_pinchStrength(cast(void*)swigCPtr);
    return ret;
  }

  public float grabStrength() const {
    auto ret = Leap_im.Hand_grabStrength(cast(void*)swigCPtr);
    return ret;
  }

  public Vector translation(Frame sinceFrame) const {
    Vector ret = new Vector(Leap_im.Hand_translation(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float translationProbability(Frame sinceFrame) const {
    auto ret = Leap_im.Hand_translationProbability(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector rotationAxis(Frame sinceFrame) const {
    Vector ret = new Vector(Leap_im.Hand_rotationAxis(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float rotationAngle(Frame sinceFrame) const {
    auto ret = Leap_im.Hand_rotationAngle__SWIG_0(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float rotationAngle(Frame sinceFrame, Vector axis) const {
    auto ret = Leap_im.Hand_rotationAngle__SWIG_1(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame), Vector.swigGetCPtr(axis));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Matrix rotationMatrix(Frame sinceFrame) const {
    Matrix ret = new Matrix(Leap_im.Hand_rotationMatrix(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float rotationProbability(Frame sinceFrame) const {
    auto ret = Leap_im.Hand_rotationProbability(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float scaleFactor(Frame sinceFrame) const {
    auto ret = Leap_im.Hand_scaleFactor(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float scaleProbability(Frame sinceFrame) const {
    auto ret = Leap_im.Hand_scaleProbability(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float timeVisible() const {
    auto ret = Leap_im.Hand_timeVisible(cast(void*)swigCPtr);
    return ret;
  }

  public float confidence() const {
    auto ret = Leap_im.Hand_confidence(cast(void*)swigCPtr);
    return ret;
  }

  public bool isLeft() const {
    bool ret = Leap_im.Hand_isLeft(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isRight() const {
    bool ret = Leap_im.Hand_isRight(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Hand_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Hand invalid() {
    Hand ret = new Hand(Leap_im.Hand_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Hand arg0) const {
    bool ret = Leap_im.Hand_swigOpEquals(cast(void*)swigCPtr, Hand.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Hand_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Gesture : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Gesture_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Gesture(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum Type {
    TYPE_INVALID = -1,
    TYPE_SWIPE = 1,
    TYPE_CIRCLE = 4,
    TYPE_SCREEN_TAP = 5,
    TYPE_KEY_TAP = 6
  }

  enum State {
    STATE_INVALID = -1,
    STATE_START = 1,
    STATE_UPDATE = 2,
    STATE_STOP = 3
  }

  public this() {
    this(Leap_im.new_Gesture__SWIG_0(), true);
  }

  public this(Gesture rhs) {
    this(Leap_im.new_Gesture__SWIG_1(Gesture.swigGetCPtr(rhs)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public Gesture.Type type() const {
    Gesture.Type ret = cast(Gesture.Type)Leap_im.Gesture_type(cast(void*)swigCPtr);
    return ret;
  }

  public Gesture.State state() const {
    Gesture.State ret = cast(Gesture.State)Leap_im.Gesture_state(cast(void*)swigCPtr);
    return ret;
  }

  public int id() const {
    auto ret = Leap_im.Gesture_id(cast(void*)swigCPtr);
    return ret;
  }

  public long duration() const {
    auto ret = Leap_im.Gesture_duration(cast(void*)swigCPtr);
    return ret;
  }

  public float durationSeconds() const {
    auto ret = Leap_im.Gesture_durationSeconds(cast(void*)swigCPtr);
    return ret;
  }

  public Frame frame() const {
    Frame ret = new Frame(Leap_im.Gesture_frame(cast(void*)swigCPtr), true);
    return ret;
  }

  public HandList hands() const {
    HandList ret = new HandList(Leap_im.Gesture_hands(cast(void*)swigCPtr), true);
    return ret;
  }

  public PointableList pointables() const {
    PointableList ret = new PointableList(Leap_im.Gesture_pointables(cast(void*)swigCPtr), true);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Gesture_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool swigOpEquals(Gesture rhs) const {
    bool ret = Leap_im.Gesture_swigOpEquals(cast(void*)swigCPtr, Gesture.swigGetCPtr(rhs)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Gesture_toString(cast(void*)swigCPtr));
    return ret;
  }

  public static Gesture invalid() {
    Gesture ret = new Gesture(Leap_im.Gesture_invalid(), false);
    return ret;
  }
}

class SwipeGesture : Gesture {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.SwipeGesture_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_SwipeGesture(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public static Gesture.Type classType() {
    Gesture.Type ret = cast(Gesture.Type)Leap_im.SwipeGesture_classType();
    return ret;
  }

  public this() {
    this(Leap_im.new_SwipeGesture__SWIG_0(), true);
  }

  public this(Gesture rhs) {
    this(Leap_im.new_SwipeGesture__SWIG_1(Gesture.swigGetCPtr(rhs)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public Vector startPosition() const {
    Vector ret = new Vector(Leap_im.SwipeGesture_startPosition(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector position() const {
    Vector ret = new Vector(Leap_im.SwipeGesture_position(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector direction() const {
    Vector ret = new Vector(Leap_im.SwipeGesture_direction(cast(void*)swigCPtr), true);
    return ret;
  }

  public float speed() const {
    auto ret = Leap_im.SwipeGesture_speed(cast(void*)swigCPtr);
    return ret;
  }

  public Pointable pointable() const {
    Pointable ret = new Pointable(Leap_im.SwipeGesture_pointable(cast(void*)swigCPtr), true);
    return ret;
  }
}

class CircleGesture : Gesture {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.CircleGesture_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_CircleGesture(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public static Gesture.Type classType() {
    Gesture.Type ret = cast(Gesture.Type)Leap_im.CircleGesture_classType();
    return ret;
  }

  public this() {
    this(Leap_im.new_CircleGesture__SWIG_0(), true);
  }

  public this(Gesture rhs) {
    this(Leap_im.new_CircleGesture__SWIG_1(Gesture.swigGetCPtr(rhs)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public Vector center() const {
    Vector ret = new Vector(Leap_im.CircleGesture_center(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector normal() const {
    Vector ret = new Vector(Leap_im.CircleGesture_normal(cast(void*)swigCPtr), true);
    return ret;
  }

  public float progress() const {
    auto ret = Leap_im.CircleGesture_progress(cast(void*)swigCPtr);
    return ret;
  }

  public float radius() const {
    auto ret = Leap_im.CircleGesture_radius(cast(void*)swigCPtr);
    return ret;
  }

  public Pointable pointable() const {
    Pointable ret = new Pointable(Leap_im.CircleGesture_pointable(cast(void*)swigCPtr), true);
    return ret;
  }
}

class ScreenTapGesture : Gesture {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.ScreenTapGesture_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_ScreenTapGesture(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public static Gesture.Type classType() {
    Gesture.Type ret = cast(Gesture.Type)Leap_im.ScreenTapGesture_classType();
    return ret;
  }

  public this() {
    this(Leap_im.new_ScreenTapGesture__SWIG_0(), true);
  }

  public this(Gesture rhs) {
    this(Leap_im.new_ScreenTapGesture__SWIG_1(Gesture.swigGetCPtr(rhs)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public Vector position() const {
    Vector ret = new Vector(Leap_im.ScreenTapGesture_position(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector direction() const {
    Vector ret = new Vector(Leap_im.ScreenTapGesture_direction(cast(void*)swigCPtr), true);
    return ret;
  }

  public float progress() const {
    auto ret = Leap_im.ScreenTapGesture_progress(cast(void*)swigCPtr);
    return ret;
  }

  public Pointable pointable() const {
    Pointable ret = new Pointable(Leap_im.ScreenTapGesture_pointable(cast(void*)swigCPtr), true);
    return ret;
  }
}

class KeyTapGesture : Gesture {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.KeyTapGesture_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_KeyTapGesture(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public static Gesture.Type classType() {
    Gesture.Type ret = cast(Gesture.Type)Leap_im.KeyTapGesture_classType();
    return ret;
  }

  public this() {
    this(Leap_im.new_KeyTapGesture__SWIG_0(), true);
  }

  public this(Gesture rhs) {
    this(Leap_im.new_KeyTapGesture__SWIG_1(Gesture.swigGetCPtr(rhs)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public Vector position() const {
    Vector ret = new Vector(Leap_im.KeyTapGesture_position(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector direction() const {
    Vector ret = new Vector(Leap_im.KeyTapGesture_direction(cast(void*)swigCPtr), true);
    return ret;
  }

  public float progress() const {
    auto ret = Leap_im.KeyTapGesture_progress(cast(void*)swigCPtr);
    return ret;
  }

  public Pointable pointable() const {
    Pointable ret = new Pointable(Leap_im.KeyTapGesture_pointable(cast(void*)swigCPtr), true);
    return ret;
  }
}

class Screen : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Screen_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Screen(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_Screen(), true);
  }

  public int id() const {
    auto ret = Leap_im.Screen_id(cast(void*)swigCPtr);
    return ret;
  }

  public Vector intersect(Pointable pointable, bool normalize, float clampRatio) const {
    Vector ret = new Vector(Leap_im.Screen_intersect__SWIG_0(cast(void*)swigCPtr, Pointable.swigGetCPtr(pointable), normalize, clampRatio), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector intersect(Pointable pointable, bool normalize) const {
    Vector ret = new Vector(Leap_im.Screen_intersect__SWIG_1(cast(void*)swigCPtr, Pointable.swigGetCPtr(pointable), normalize), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector intersect(Vector position, Vector direction, bool normalize, float clampRatio) const {
    Vector ret = new Vector(Leap_im.Screen_intersect__SWIG_2(cast(void*)swigCPtr, Vector.swigGetCPtr(position), Vector.swigGetCPtr(direction), normalize, clampRatio), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector intersect(Vector position, Vector direction, bool normalize) const {
    Vector ret = new Vector(Leap_im.Screen_intersect__SWIG_3(cast(void*)swigCPtr, Vector.swigGetCPtr(position), Vector.swigGetCPtr(direction), normalize), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector project(Vector position, bool normalize, float clampRatio) const {
    Vector ret = new Vector(Leap_im.Screen_project__SWIG_0(cast(void*)swigCPtr, Vector.swigGetCPtr(position), normalize, clampRatio), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector project(Vector position, bool normalize) const {
    Vector ret = new Vector(Leap_im.Screen_project__SWIG_1(cast(void*)swigCPtr, Vector.swigGetCPtr(position), normalize), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector horizontalAxis() const {
    Vector ret = new Vector(Leap_im.Screen_horizontalAxis(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector verticalAxis() const {
    Vector ret = new Vector(Leap_im.Screen_verticalAxis(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector bottomLeftCorner() const {
    Vector ret = new Vector(Leap_im.Screen_bottomLeftCorner(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector normal() const {
    Vector ret = new Vector(Leap_im.Screen_normal(cast(void*)swigCPtr), true);
    return ret;
  }

  public int widthPixels() const {
    auto ret = Leap_im.Screen_widthPixels(cast(void*)swigCPtr);
    return ret;
  }

  public int heightPixels() const {
    auto ret = Leap_im.Screen_heightPixels(cast(void*)swigCPtr);
    return ret;
  }

  public float distanceToPoint(Vector point) const {
    auto ret = Leap_im.Screen_distanceToPoint(cast(void*)swigCPtr, Vector.swigGetCPtr(point));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Screen_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Screen invalid() {
    Screen ret = new Screen(Leap_im.Screen_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Screen arg0) const {
    bool ret = Leap_im.Screen_swigOpEquals(cast(void*)swigCPtr, Screen.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Screen_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Device : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Device_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Device(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum Type {
    TYPE_PERIPHERAL = 1,
    TYPE_LAPTOP,
    TYPE_KEYBOARD
  }

  public this() {
    this(Leap_im.new_Device(), true);
  }

  public float horizontalViewAngle() const {
    auto ret = Leap_im.Device_horizontalViewAngle(cast(void*)swigCPtr);
    return ret;
  }

  public float verticalViewAngle() const {
    auto ret = Leap_im.Device_verticalViewAngle(cast(void*)swigCPtr);
    return ret;
  }

  public float range() const {
    auto ret = Leap_im.Device_range(cast(void*)swigCPtr);
    return ret;
  }

  public float baseline() const {
    auto ret = Leap_im.Device_baseline(cast(void*)swigCPtr);
    return ret;
  }

  public float distanceToBoundary(Vector position) const {
    auto ret = Leap_im.Device_distanceToBoundary(cast(void*)swigCPtr, Vector.swigGetCPtr(position));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool isEmbedded() const {
    bool ret = Leap_im.Device_isEmbedded(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isStreaming() const {
    bool ret = Leap_im.Device_isStreaming(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isFlipped() const {
    bool ret = Leap_im.Device_isFlipped(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Device.Type type() const {
    Device.Type ret = cast(Device.Type)Leap_im.Device_type(cast(void*)swigCPtr);
    return ret;
  }

  public string serialNumber() const {
    string ret = std.conv.to!string(Leap_im.Device_serialNumber(cast(void*)swigCPtr));
    return ret;
  }

  public Vector position() const {
    Vector ret = new Vector(Leap_im.Device_position(cast(void*)swigCPtr), true);
    return ret;
  }

  public Matrix orientation() const {
    Matrix ret = new Matrix(Leap_im.Device_orientation(cast(void*)swigCPtr), true);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Device_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Device invalid() {
    Device ret = new Device(Leap_im.Device_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Device arg0) const {
    bool ret = Leap_im.Device_swigOpEquals(cast(void*)swigCPtr, Device.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Device_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Image : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Image_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Image(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum FormatType {
    INFRARED = 0
  }

  public this() {
    this(Leap_im.new_Image(), true);
  }

  public long sequenceId() const {
    auto ret = Leap_im.Image_sequenceId(cast(void*)swigCPtr);
    return ret;
  }

  public int id() const {
    auto ret = Leap_im.Image_id(cast(void*)swigCPtr);
    return ret;
  }

  public void data(ubyte* dst) const {
    Leap_im.Image_data(cast(void*)swigCPtr, cast(void*)dst);
  }

  public void distortion(float* dst) const {
    Leap_im.Image_distortion(cast(void*)swigCPtr, cast(void*)dst);
  }

  public int width() const {
    auto ret = Leap_im.Image_width(cast(void*)swigCPtr);
    return ret;
  }

  public int height() const {
    auto ret = Leap_im.Image_height(cast(void*)swigCPtr);
    return ret;
  }

  public int bytesPerPixel() const {
    auto ret = Leap_im.Image_bytesPerPixel(cast(void*)swigCPtr);
    return ret;
  }

  public Image.FormatType format() const {
    Image.FormatType ret = cast(Image.FormatType)Leap_im.Image_format(cast(void*)swigCPtr);
    return ret;
  }

  public int distortionWidth() const {
    auto ret = Leap_im.Image_distortionWidth(cast(void*)swigCPtr);
    return ret;
  }

  public int distortionHeight() const {
    auto ret = Leap_im.Image_distortionHeight(cast(void*)swigCPtr);
    return ret;
  }

  public float rayOffsetX() const {
    auto ret = Leap_im.Image_rayOffsetX(cast(void*)swigCPtr);
    return ret;
  }

  public float rayOffsetY() const {
    auto ret = Leap_im.Image_rayOffsetY(cast(void*)swigCPtr);
    return ret;
  }

  public float rayScaleX() const {
    auto ret = Leap_im.Image_rayScaleX(cast(void*)swigCPtr);
    return ret;
  }

  public float rayScaleY() const {
    auto ret = Leap_im.Image_rayScaleY(cast(void*)swigCPtr);
    return ret;
  }

  public Vector rectify(Vector uv) const {
    Vector ret = new Vector(Leap_im.Image_rectify(cast(void*)swigCPtr, Vector.swigGetCPtr(uv)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector warp(Vector xy) const {
    Vector ret = new Vector(Leap_im.Image_warp(cast(void*)swigCPtr, Vector.swigGetCPtr(xy)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public long timestamp() const {
    auto ret = Leap_im.Image_timestamp(cast(void*)swigCPtr);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Image_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Image invalid() {
    Image ret = new Image(Leap_im.Image_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Image arg0) const {
    bool ret = Leap_im.Image_swigOpEquals(cast(void*)swigCPtr, Image.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Image_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Mask : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Mask_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Mask(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_Mask(), true);
  }

  public long sequenceId() const {
    auto ret = Leap_im.Mask_sequenceId(cast(void*)swigCPtr);
    return ret;
  }

  public int id() const {
    auto ret = Leap_im.Mask_id(cast(void*)swigCPtr);
    return ret;
  }

  public void data(ubyte* dst) const {
    Leap_im.Mask_data(cast(void*)swigCPtr, cast(void*)dst);
  }

  public int width() const {
    auto ret = Leap_im.Mask_width(cast(void*)swigCPtr);
    return ret;
  }

  public int height() const {
    auto ret = Leap_im.Mask_height(cast(void*)swigCPtr);
    return ret;
  }

  public int offsetX() const {
    auto ret = Leap_im.Mask_offsetX(cast(void*)swigCPtr);
    return ret;
  }

  public int offsetY() const {
    auto ret = Leap_im.Mask_offsetY(cast(void*)swigCPtr);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Mask_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Mask invalid() {
    Mask ret = new Mask(Leap_im.Mask_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Mask arg0) const {
    bool ret = Leap_im.Mask_swigOpEquals(cast(void*)swigCPtr, Mask.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Mask_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class PointableList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.PointableList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_PointableList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_PointableList(), true);
  }

  public int count() const {
    auto ret = Leap_im.PointableList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.PointableList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Pointable opIndex(int index) const {
    Pointable ret = new Pointable(Leap_im.PointableList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public PointableList append(PointableList other) {
    PointableList ret = new PointableList(Leap_im.PointableList_append__SWIG_0(cast(void*)swigCPtr, PointableList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public PointableList append(FingerList other) {
    PointableList ret = new PointableList(Leap_im.PointableList_append__SWIG_1(cast(void*)swigCPtr, FingerList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public PointableList append(ToolList other) {
    PointableList ret = new PointableList(Leap_im.PointableList_append__SWIG_2(cast(void*)swigCPtr, ToolList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Pointable leftmost() const {
    Pointable ret = new Pointable(Leap_im.PointableList_leftmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Pointable rightmost() const {
    Pointable ret = new Pointable(Leap_im.PointableList_rightmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Pointable frontmost() const {
    Pointable ret = new Pointable(Leap_im.PointableList_frontmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public PointableList extended() const {
    PointableList ret = new PointableList(Leap_im.PointableList_extended(cast(void*)swigCPtr), true);
    return ret;
  }
}

class FingerList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.FingerList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_FingerList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_FingerList(), true);
  }

  public int count() const {
    auto ret = Leap_im.FingerList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.FingerList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Finger opIndex(int index) const {
    Finger ret = new Finger(Leap_im.FingerList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public FingerList append(FingerList other) {
    FingerList ret = new FingerList(Leap_im.FingerList_append(cast(void*)swigCPtr, FingerList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Finger leftmost() const {
    Finger ret = new Finger(Leap_im.FingerList_leftmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Finger rightmost() const {
    Finger ret = new Finger(Leap_im.FingerList_rightmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Finger frontmost() const {
    Finger ret = new Finger(Leap_im.FingerList_frontmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public FingerList extended() const {
    FingerList ret = new FingerList(Leap_im.FingerList_extended(cast(void*)swigCPtr), true);
    return ret;
  }

  public FingerList fingerType(Finger.Type type) const {
    FingerList ret = new FingerList(Leap_im.FingerList_fingerType(cast(void*)swigCPtr, cast(int)type), true);
    return ret;
  }
}

class ToolList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.ToolList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_ToolList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_ToolList(), true);
  }

  public int count() const {
    auto ret = Leap_im.ToolList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.ToolList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Tool opIndex(int index) const {
    Tool ret = new Tool(Leap_im.ToolList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public ToolList append(ToolList other) {
    ToolList ret = new ToolList(Leap_im.ToolList_append(cast(void*)swigCPtr, ToolList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Tool leftmost() const {
    Tool ret = new Tool(Leap_im.ToolList_leftmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Tool rightmost() const {
    Tool ret = new Tool(Leap_im.ToolList_rightmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Tool frontmost() const {
    Tool ret = new Tool(Leap_im.ToolList_frontmost(cast(void*)swigCPtr), true);
    return ret;
  }
}

class HandList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.HandList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_HandList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_HandList(), true);
  }

  public int count() const {
    auto ret = Leap_im.HandList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.HandList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Hand opIndex(int index) const {
    Hand ret = new Hand(Leap_im.HandList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public HandList append(HandList other) {
    HandList ret = new HandList(Leap_im.HandList_append(cast(void*)swigCPtr, HandList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Hand leftmost() const {
    Hand ret = new Hand(Leap_im.HandList_leftmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Hand rightmost() const {
    Hand ret = new Hand(Leap_im.HandList_rightmost(cast(void*)swigCPtr), true);
    return ret;
  }

  public Hand frontmost() const {
    Hand ret = new Hand(Leap_im.HandList_frontmost(cast(void*)swigCPtr), true);
    return ret;
  }
}

class GestureList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.GestureList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_GestureList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_GestureList(), true);
  }

  public int count() const {
    auto ret = Leap_im.GestureList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.GestureList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Gesture opIndex(int index) const {
    Gesture ret = new Gesture(Leap_im.GestureList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public GestureList append(GestureList other) {
    GestureList ret = new GestureList(Leap_im.GestureList_append(cast(void*)swigCPtr, GestureList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }
}

class ScreenList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.ScreenList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_ScreenList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_ScreenList(), true);
  }

  public int count() const {
    auto ret = Leap_im.ScreenList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.ScreenList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Screen opIndex(int index) const {
    Screen ret = new Screen(Leap_im.ScreenList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public Screen closestScreenHit(Pointable pointable) const {
    Screen ret = new Screen(Leap_im.ScreenList_closestScreenHit__SWIG_0(cast(void*)swigCPtr, Pointable.swigGetCPtr(pointable)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Screen closestScreenHit(Vector position, Vector direction) const {
    Screen ret = new Screen(Leap_im.ScreenList_closestScreenHit__SWIG_1(cast(void*)swigCPtr, Vector.swigGetCPtr(position), Vector.swigGetCPtr(direction)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Screen closestScreen(Vector position) const {
    Screen ret = new Screen(Leap_im.ScreenList_closestScreen(cast(void*)swigCPtr, Vector.swigGetCPtr(position)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }
}

class DeviceList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.DeviceList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_DeviceList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_DeviceList(), true);
  }

  public int count() const {
    auto ret = Leap_im.DeviceList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.DeviceList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Device opIndex(int index) const {
    Device ret = new Device(Leap_im.DeviceList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public DeviceList append(DeviceList other) {
    DeviceList ret = new DeviceList(Leap_im.DeviceList_append(cast(void*)swigCPtr, DeviceList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }
}

class ImageList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.ImageList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_ImageList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_ImageList(), true);
  }

  public int count() const {
    auto ret = Leap_im.ImageList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.ImageList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Image opIndex(int index) const {
    Image ret = new Image(Leap_im.ImageList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public ImageList append(ImageList other) {
    ImageList ret = new ImageList(Leap_im.ImageList_append(cast(void*)swigCPtr, ImageList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }
}

class TrackedQuad : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.TrackedQuad_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_TrackedQuad(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_TrackedQuad(), true);
  }

  public float width() const {
    auto ret = Leap_im.TrackedQuad_width(cast(void*)swigCPtr);
    return ret;
  }

  public float height() const {
    auto ret = Leap_im.TrackedQuad_height(cast(void*)swigCPtr);
    return ret;
  }

  public int resolutionX() const {
    auto ret = Leap_im.TrackedQuad_resolutionX(cast(void*)swigCPtr);
    return ret;
  }

  public int resolutionY() const {
    auto ret = Leap_im.TrackedQuad_resolutionY(cast(void*)swigCPtr);
    return ret;
  }

  public bool visible() const {
    bool ret = Leap_im.TrackedQuad_visible(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Matrix orientation() const {
    Matrix ret = new Matrix(Leap_im.TrackedQuad_orientation(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector position() const {
    Vector ret = new Vector(Leap_im.TrackedQuad_position(cast(void*)swigCPtr), true);
    return ret;
  }

  public MaskList masks() const {
    MaskList ret = new MaskList(Leap_im.TrackedQuad_masks(cast(void*)swigCPtr), true);
    return ret;
  }

  public ImageList images() const {
    ImageList ret = new ImageList(Leap_im.TrackedQuad_images(cast(void*)swigCPtr), true);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.TrackedQuad_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static TrackedQuad invalid() {
    TrackedQuad ret = new TrackedQuad(Leap_im.TrackedQuad_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(TrackedQuad arg0) const {
    bool ret = Leap_im.TrackedQuad_swigOpEquals(cast(void*)swigCPtr, TrackedQuad.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.TrackedQuad_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class MaskList : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.MaskList_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_MaskList(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_MaskList(), true);
  }

  public int count() const {
    auto ret = Leap_im.MaskList_count(cast(void*)swigCPtr);
    return ret;
  }

  public bool isEmpty() const {
    bool ret = Leap_im.MaskList_isEmpty(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Mask opIndex(int index) const {
    Mask ret = new Mask(Leap_im.MaskList_opIndex(cast(void*)swigCPtr, index), true);
    return ret;
  }

  public MaskList append(MaskList other) {
    MaskList ret = new MaskList(Leap_im.MaskList_append(cast(void*)swigCPtr, MaskList.swigGetCPtr(other)), false);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }
}

class InteractionBox : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.InteractionBox_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_InteractionBox(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_InteractionBox(), true);
  }

  public Vector normalizePoint(Vector position, bool clamp) const {
    Vector ret = new Vector(Leap_im.InteractionBox_normalizePoint__SWIG_0(cast(void*)swigCPtr, Vector.swigGetCPtr(position), clamp), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector normalizePoint(Vector position) const {
    Vector ret = new Vector(Leap_im.InteractionBox_normalizePoint__SWIG_1(cast(void*)swigCPtr, Vector.swigGetCPtr(position)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector denormalizePoint(Vector normalizedPosition) const {
    Vector ret = new Vector(Leap_im.InteractionBox_denormalizePoint(cast(void*)swigCPtr, Vector.swigGetCPtr(normalizedPosition)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector center() const {
    Vector ret = new Vector(Leap_im.InteractionBox_center(cast(void*)swigCPtr), true);
    return ret;
  }

  public float width() const {
    auto ret = Leap_im.InteractionBox_width(cast(void*)swigCPtr);
    return ret;
  }

  public float height() const {
    auto ret = Leap_im.InteractionBox_height(cast(void*)swigCPtr);
    return ret;
  }

  public float depth() const {
    auto ret = Leap_im.InteractionBox_depth(cast(void*)swigCPtr);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.InteractionBox_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static InteractionBox invalid() {
    InteractionBox ret = new InteractionBox(Leap_im.InteractionBox_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(InteractionBox arg0) const {
    bool ret = Leap_im.InteractionBox_swigOpEquals(cast(void*)swigCPtr, InteractionBox.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.InteractionBox_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class Frame : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Frame_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Frame(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_Frame(), true);
  }

  public long id() const {
    auto ret = Leap_im.Frame_id(cast(void*)swigCPtr);
    return ret;
  }

  public long timestamp() const {
    auto ret = Leap_im.Frame_timestamp(cast(void*)swigCPtr);
    return ret;
  }

  public HandList hands() const {
    HandList ret = new HandList(Leap_im.Frame_hands(cast(void*)swigCPtr), true);
    return ret;
  }

  public Hand hand(int id) const {
    Hand ret = new Hand(Leap_im.Frame_hand(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public PointableList pointables() const {
    PointableList ret = new PointableList(Leap_im.Frame_pointables(cast(void*)swigCPtr), true);
    return ret;
  }

  public Pointable pointable(int id) const {
    Pointable ret = new Pointable(Leap_im.Frame_pointable(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public FingerList fingers() const {
    FingerList ret = new FingerList(Leap_im.Frame_fingers(cast(void*)swigCPtr), true);
    return ret;
  }

  public Finger finger(int id) const {
    Finger ret = new Finger(Leap_im.Frame_finger(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public ToolList tools() const {
    ToolList ret = new ToolList(Leap_im.Frame_tools(cast(void*)swigCPtr), true);
    return ret;
  }

  public Tool tool(int id) const {
    Tool ret = new Tool(Leap_im.Frame_tool(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public Gesture gesture(int id) const {
    Gesture ret = new Gesture(Leap_im.Frame_gesture(cast(void*)swigCPtr, id), true);
    return ret;
  }

  public GestureList gestures() const {
    GestureList ret = new GestureList(Leap_im.Frame_gestures__SWIG_0(cast(void*)swigCPtr), true);
    return ret;
  }

  public GestureList gestures(Frame sinceFrame) const {
    GestureList ret = new GestureList(Leap_im.Frame_gestures__SWIG_1(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public ImageList images() const {
    ImageList ret = new ImageList(Leap_im.Frame_images(cast(void*)swigCPtr), true);
    return ret;
  }

  public Vector translation(Frame sinceFrame) const {
    Vector ret = new Vector(Leap_im.Frame_translation(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float translationProbability(Frame sinceFrame) const {
    auto ret = Leap_im.Frame_translationProbability(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Vector rotationAxis(Frame sinceFrame) const {
    Vector ret = new Vector(Leap_im.Frame_rotationAxis(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float rotationAngle(Frame sinceFrame) const {
    auto ret = Leap_im.Frame_rotationAngle__SWIG_0(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float rotationAngle(Frame sinceFrame, Vector axis) const {
    auto ret = Leap_im.Frame_rotationAngle__SWIG_1(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame), Vector.swigGetCPtr(axis));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Matrix rotationMatrix(Frame sinceFrame) const {
    Matrix ret = new Matrix(Leap_im.Frame_rotationMatrix(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float rotationProbability(Frame sinceFrame) const {
    auto ret = Leap_im.Frame_rotationProbability(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float scaleFactor(Frame sinceFrame) const {
    auto ret = Leap_im.Frame_scaleFactor(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float scaleProbability(Frame sinceFrame) const {
    auto ret = Leap_im.Frame_scaleProbability(cast(void*)swigCPtr, Frame.swigGetCPtr(sinceFrame));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public InteractionBox interactionBox() const {
    InteractionBox ret = new InteractionBox(Leap_im.Frame_interactionBox(cast(void*)swigCPtr), true);
    return ret;
  }

  public float currentFramesPerSecond() const {
    auto ret = Leap_im.Frame_currentFramesPerSecond(cast(void*)swigCPtr);
    return ret;
  }

  public bool isValid() const {
    bool ret = Leap_im.Frame_isValid(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public static Frame invalid() {
    Frame ret = new Frame(Leap_im.Frame_invalid(), false);
    return ret;
  }

  public bool swigOpEquals(Frame arg0) const {
    bool ret = Leap_im.Frame_swigOpEquals(cast(void*)swigCPtr, Frame.swigGetCPtr(arg0)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public TrackedQuad trackedQuad() const {
    TrackedQuad ret = new TrackedQuad(Leap_im.Frame_trackedQuad(cast(void*)swigCPtr), true);
    return ret;
  }

  public void serialize(ubyte* ptr) const {
    Leap_im.Frame_serialize(cast(void*)swigCPtr, cast(void*)ptr);
  }

  public int serializeLength() const {
    auto ret = Leap_im.Frame_serializeLength(cast(void*)swigCPtr);
    return ret;
  }

  public void deserialize(ubyte* ptr, int length) {
    Leap_im.Frame_deserialize(cast(void*)swigCPtr, cast(void*)ptr, length);
  }

  public string toString() const {
    string ret = std.conv.to!string(Leap_im.Frame_toString(cast(void*)swigCPtr));
    return ret;
  }
}

class BugReport : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.BugReport_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_BugReport(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  public this() {
    this(Leap_im.new_BugReport(), true);
  }

  public bool beginRecording() {
    bool ret = Leap_im.BugReport_beginRecording(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public void endRecording() {
    Leap_im.BugReport_endRecording(cast(void*)swigCPtr);
  }

  public bool isActive() const {
    bool ret = Leap_im.BugReport_isActive(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public float progress() const {
    auto ret = Leap_im.BugReport_progress(cast(void*)swigCPtr);
    return ret;
  }

  public float duration() const {
    auto ret = Leap_im.BugReport_duration(cast(void*)swigCPtr);
    return ret;
  }
}

class Config : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Config_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Config(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum ValueType {
    TYPE_UNKNOWN = 0,
    TYPE_BOOLEAN = 1,
    TYPE_INT32 = 2,
    TYPE_FLOAT = 6,
    TYPE_STRING = 8
  }

  public this() {
    this(Leap_im.new_Config(), true);
  }

  public Config.ValueType type(string key) const {
    Config.ValueType ret = cast(Config.ValueType)Leap_im.Config_type(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool getBool(string key) const {
    bool ret = Leap_im.Config_getBool(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool setBool(string key, bool value) {
    bool ret = Leap_im.Config_setBool(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null), value) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public int getInt32(string key) const {
    auto ret = Leap_im.Config_getInt32(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool setInt32(string key, int value) {
    bool ret = Leap_im.Config_setInt32(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null), value) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public float getFloat(string key) const {
    auto ret = Leap_im.Config_getFloat(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool setFloat(string key, float value) {
    bool ret = Leap_im.Config_setFloat(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null), value) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public string getString(string key) const {
    string ret = std.conv.to!string(Leap_im.Config_getString(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null)));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool setString(string key, string value) {
    bool ret = Leap_im.Config_setString(cast(void*)swigCPtr, (key ? std.string.toStringz(key) : null), (value ? std.string.toStringz(value) : null)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool save() {
    bool ret = Leap_im.Config_save(cast(void*)swigCPtr) ? true : false;
    return ret;
  }
}

class Controller : Interface {
  private void* swigCPtr;

  public this(void* cObject, bool ownCObject) {
    super(Leap_im.Controller_Upcast(cObject), ownCObject);
    swigCPtr = cObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public override void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Controller(cast(void*)swigCPtr);
        }
        swigCPtr = null;
        super.dispose();
      }
    }
  }

  enum PolicyFlag {
    POLICY_DEFAULT = 0,
    POLICY_BACKGROUND_FRAMES = (1 << 0),
    POLICY_IMAGES = (1 << 1),
    POLICY_OPTIMIZE_HMD = (1 << 2)
  }

  public this() {
    this(Leap_im.new_Controller__SWIG_0(), true);
  }

  public this(Listener listener) {
    this(Leap_im.new_Controller__SWIG_1(Listener.swigGetCPtr(listener)), true);
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public bool isConnected() const {
    bool ret = Leap_im.Controller_isConnected(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool isServiceConnected() const {
    bool ret = Leap_im.Controller_isServiceConnected(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public bool hasFocus() const {
    bool ret = Leap_im.Controller_hasFocus(cast(void*)swigCPtr) ? true : false;
    return ret;
  }

  public Controller.PolicyFlag policyFlags() const {
    Controller.PolicyFlag ret = cast(Controller.PolicyFlag)Leap_im.Controller_policyFlags(cast(void*)swigCPtr);
    return ret;
  }

  public void setPolicyFlags(Controller.PolicyFlag flags) const {
    Leap_im.Controller_setPolicyFlags(cast(void*)swigCPtr, cast(int)flags);
  }

  public void setPolicy(Controller.PolicyFlag policy) const {
    Leap_im.Controller_setPolicy(cast(void*)swigCPtr, cast(int)policy);
  }

  public void clearPolicy(Controller.PolicyFlag policy) const {
    Leap_im.Controller_clearPolicy(cast(void*)swigCPtr, cast(int)policy);
  }

  public bool isPolicySet(Controller.PolicyFlag policy) const {
    bool ret = Leap_im.Controller_isPolicySet(cast(void*)swigCPtr, cast(int)policy) ? true : false;
    return ret;
  }

  public bool addListener(Listener listener) {
    bool ret = Leap_im.Controller_addListener(cast(void*)swigCPtr, Listener.swigGetCPtr(listener)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public bool removeListener(Listener listener) {
    bool ret = Leap_im.Controller_removeListener(cast(void*)swigCPtr, Listener.swigGetCPtr(listener)) ? true : false;
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
    return ret;
  }

  public Frame frame(int history) const {
    Frame ret = new Frame(Leap_im.Controller_frame__SWIG_0(cast(void*)swigCPtr, history), true);
    return ret;
  }

  public Frame frame() const {
    Frame ret = new Frame(Leap_im.Controller_frame__SWIG_1(cast(void*)swigCPtr), true);
    return ret;
  }

  public ImageList images() const {
    ImageList ret = new ImageList(Leap_im.Controller_images(cast(void*)swigCPtr), true);
    return ret;
  }

  public Config config() const {
    Config ret = new Config(Leap_im.Controller_config(cast(void*)swigCPtr), true);
    return ret;
  }

  public DeviceList devices() const {
    DeviceList ret = new DeviceList(Leap_im.Controller_devices(cast(void*)swigCPtr), true);
    return ret;
  }

  public ScreenList locatedScreens() const {
    ScreenList ret = new ScreenList(Leap_im.Controller_locatedScreens(cast(void*)swigCPtr), true);
    return ret;
  }

  public BugReport bugReport() const {
    BugReport ret = new BugReport(Leap_im.Controller_bugReport(cast(void*)swigCPtr), true);
    return ret;
  }

  public void enableGesture(Gesture.Type type, bool enable) const {
    Leap_im.Controller_enableGesture__SWIG_0(cast(void*)swigCPtr, cast(int)type, enable);
  }

  public void enableGesture(Gesture.Type type) const {
    Leap_im.Controller_enableGesture__SWIG_1(cast(void*)swigCPtr, cast(int)type);
  }

  public bool isGestureEnabled(Gesture.Type type) const {
    bool ret = Leap_im.Controller_isGestureEnabled(cast(void*)swigCPtr, cast(int)type) ? true : false;
    return ret;
  }

  public TrackedQuad trackedQuad() const {
    TrackedQuad ret = new TrackedQuad(Leap_im.Controller_trackedQuad(cast(void*)swigCPtr), true);
    return ret;
  }

  public long now() const {
    auto ret = Leap_im.Controller_now(cast(void*)swigCPtr);
    return ret;
  }
}

class Listener {
  private void* swigCPtr;
  protected bool swigCMemOwn;

  public this(void* cObject, bool ownCObject) {
    swigCPtr = cObject;
    swigCMemOwn = ownCObject;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;

  ~this() {
    dispose();
  }

  public void dispose() {
    synchronized(this) {
      if (swigCPtr !is null) {
        if (swigCMemOwn) {
          swigCMemOwn = false;
          Leap_im.delete_Listener(cast(void*)swigCPtr);
        }
        swigCPtr = null;
      }
    }
  }

  public this() {
    this(Leap_im.new_Listener(), true);
    swigDirectorConnect();
  }

  public void onInit(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onInit)()) Leap_im.Listener_onInitSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onInit(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onConnect(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onConnect)()) Leap_im.Listener_onConnectSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onConnect(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onDisconnect(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onDisconnect)()) Leap_im.Listener_onDisconnectSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onDisconnect(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onExit(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onExit)()) Leap_im.Listener_onExitSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onExit(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onFrame(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onFrame)()) Leap_im.Listener_onFrameSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onFrame(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onFocusGained(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onFocusGained)()) Leap_im.Listener_onFocusGainedSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onFocusGained(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onFocusLost(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onFocusLost)()) Leap_im.Listener_onFocusLostSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onFocusLost(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onServiceConnect(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onServiceConnect)()) Leap_im.Listener_onServiceConnectSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onServiceConnect(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onServiceDisconnect(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onServiceDisconnect)()) Leap_im.Listener_onServiceDisconnectSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onServiceDisconnect(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onDeviceChange(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onDeviceChange)()) Leap_im.Listener_onDeviceChangeSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onDeviceChange(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  public void onImages(Controller arg0) {
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onImages)()) Leap_im.Listener_onImagesSwigExplicitListener(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0)); else Leap_im.Listener_onImages(cast(void*)swigCPtr, Controller.swigGetCPtr(arg0));
    if (Leap_im.SwigPendingException.isPending) throw Leap_im.SwigPendingException.retrieve();
  }

  private void swigDirectorConnect() {
    Leap_im.SwigDirector_Listener_Callback0 callback0;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onInit)()) {
      callback0 = &swigDirectorCallback_Listener_onInit;
    }

    Leap_im.SwigDirector_Listener_Callback1 callback1;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onConnect)()) {
      callback1 = &swigDirectorCallback_Listener_onConnect;
    }

    Leap_im.SwigDirector_Listener_Callback2 callback2;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onDisconnect)()) {
      callback2 = &swigDirectorCallback_Listener_onDisconnect;
    }

    Leap_im.SwigDirector_Listener_Callback3 callback3;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onExit)()) {
      callback3 = &swigDirectorCallback_Listener_onExit;
    }

    Leap_im.SwigDirector_Listener_Callback4 callback4;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onFrame)()) {
      callback4 = &swigDirectorCallback_Listener_onFrame;
    }

    Leap_im.SwigDirector_Listener_Callback5 callback5;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onFocusGained)()) {
      callback5 = &swigDirectorCallback_Listener_onFocusGained;
    }

    Leap_im.SwigDirector_Listener_Callback6 callback6;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onFocusLost)()) {
      callback6 = &swigDirectorCallback_Listener_onFocusLost;
    }

    Leap_im.SwigDirector_Listener_Callback7 callback7;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onServiceConnect)()) {
      callback7 = &swigDirectorCallback_Listener_onServiceConnect;
    }

    Leap_im.SwigDirector_Listener_Callback8 callback8;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onServiceDisconnect)()) {
      callback8 = &swigDirectorCallback_Listener_onServiceDisconnect;
    }

    Leap_im.SwigDirector_Listener_Callback9 callback9;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onDeviceChange)()) {
      callback9 = &swigDirectorCallback_Listener_onDeviceChange;
    }

    Leap_im.SwigDirector_Listener_Callback10 callback10;
    if (swigIsMethodOverridden!(void delegate(Controller), void function(Controller), onImages)()) {
      callback10 = &swigDirectorCallback_Listener_onImages;
    }

    Leap_im.Listener_director_connect(cast(void*)swigCPtr, cast(void*)this, callback0, callback1, callback2, callback3, callback4, callback5, callback6, callback7, callback8, callback9, callback10);
  }

  private bool swigIsMethodOverridden(DelegateType, FunctionType, alias fn)() const {
    DelegateType dg = &fn;
    return dg.funcptr != SwigNonVirtualAddressOf!(FunctionType, fn);
  }

  private static Function SwigNonVirtualAddressOf(Function, alias fn)() {
    return cast(Function) &fn;
  }
}

private extern(C) void swigDirectorCallback_Listener_onInit(void* dObject, void* arg0) {
  (cast(Listener)dObject).onInit(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onConnect(void* dObject, void* arg0) {
  (cast(Listener)dObject).onConnect(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onDisconnect(void* dObject, void* arg0) {
  (cast(Listener)dObject).onDisconnect(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onExit(void* dObject, void* arg0) {
  (cast(Listener)dObject).onExit(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onFrame(void* dObject, void* arg0) {
  (cast(Listener)dObject).onFrame(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onFocusGained(void* dObject, void* arg0) {
  (cast(Listener)dObject).onFocusGained(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onFocusLost(void* dObject, void* arg0) {
  (cast(Listener)dObject).onFocusLost(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onServiceConnect(void* dObject, void* arg0) {
  (cast(Listener)dObject).onServiceConnect(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onServiceDisconnect(void* dObject, void* arg0) {
  (cast(Listener)dObject).onServiceDisconnect(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onDeviceChange(void* dObject, void* arg0) {
  (cast(Listener)dObject).onDeviceChange(new Controller(arg0, false));
}

private extern(C) void swigDirectorCallback_Listener_onImages(void* dObject, void* arg0) {
  (cast(Listener)dObject).onImages(new Controller(arg0, false));
}

class SWIGTYPE_p_float {
  private void* swigCPtr;

  public this(void* cObject, bool futureUse) {
    swigCPtr = cObject;
  }

  protected this() {
    swigCPtr = null;
  }

  public static void* swigGetCPtr(typeof(this) obj) {
    return (obj is null) ? null : obj.swigCPtr;
  }

  mixin Leap_im.SwigOperatorDefinitions;
}
