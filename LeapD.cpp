/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.10
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */


#ifndef SWIGD
#define SWIGD
#endif

#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__))
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__))
# else
#   define SWIGUNUSED
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if defined(__GNUC__)
#  if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#    ifndef GCC_HASCLASSVISIBILITY
#      define GCC_HASCLASSVISIBILITY
#    endif
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif

/* Deal with Apple's deprecated 'AssertMacros.h' from Carbon-framework */
#if defined(__APPLE__) && !defined(__ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES)
# define __ASSERT_MACROS_DEFINE_VERSIONS_WITHOUT_UNDERSCORES 0
#endif

/* Intel's compiler complains if a variable which was never initialised is
 * cast to void, which is a common idiom which we use to indicate that we
 * are aware a variable isn't used.  So we just silence that warning.
 * See: https://github.com/swig/swig/issues/192 for more discussion.
 */
#ifdef __INTEL_COMPILER
# pragma warning disable 592
#endif


#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* Contract support. */
#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_DSetPendingException(SWIG_DException, msg); return nullreturn; } else


// Support for throwing D exceptions from C/C++.
typedef enum {
  SWIG_DException = 0,
  SWIG_DIllegalArgumentException,
  SWIG_DIllegalElementException,
  SWIG_DIOException,
  SWIG_DNoSuchElementException
} SWIG_DExceptionCodes;

typedef void (* SWIG_DExceptionCallback_t)(const char *);

typedef struct {
  SWIG_DExceptionCodes code;
  SWIG_DExceptionCallback_t callback;
} SWIG_DException_t;

static SWIG_DException_t SWIG_d_exceptions[] = {
  { SWIG_DException, NULL },
  { SWIG_DIllegalArgumentException, NULL },
  { SWIG_DIllegalElementException, NULL },
  { SWIG_DIOException, NULL },
  { SWIG_DNoSuchElementException, NULL }
};

static void SWIGUNUSED SWIG_DSetPendingException(SWIG_DExceptionCodes code, const char *msg) {
  if ((size_t)code < sizeof(SWIG_d_exceptions)/sizeof(SWIG_DException_t)) {
    SWIG_d_exceptions[code].callback(msg);
  } else {
    SWIG_d_exceptions[SWIG_DException].callback(msg);
  }
}

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void SWIGRegisterExceptionCallbacks_Leap(
  SWIG_DExceptionCallback_t exceptionCallback,
  SWIG_DExceptionCallback_t illegalArgumentCallback,
  SWIG_DExceptionCallback_t illegalElementCallback,
  SWIG_DExceptionCallback_t ioCallback,
  SWIG_DExceptionCallback_t noSuchElementCallback) {
  SWIG_d_exceptions[SWIG_DException].callback = exceptionCallback;
  SWIG_d_exceptions[SWIG_DIllegalArgumentException].callback = illegalArgumentCallback;
  SWIG_d_exceptions[SWIG_DIllegalElementException].callback = illegalElementCallback;
  SWIG_d_exceptions[SWIG_DIOException].callback = ioCallback;
  SWIG_d_exceptions[SWIG_DNoSuchElementException].callback = noSuchElementCallback;
}


// Callback for returning strings to D without leaking memory.
typedef char * (* SWIG_DStringHelperCallback)(const char *);
static SWIG_DStringHelperCallback SWIG_d_string_callback = NULL;

#ifdef __cplusplus
extern "C"
#endif
SWIGEXPORT void SWIGRegisterStringCallback_Leap(SWIG_DStringHelperCallback callback) {
  SWIG_d_string_callback = callback;
}

/* -----------------------------------------------------------------------------
 * director_common.swg
 *
 * This file contains support for director classes which is common between
 * languages.
 * ----------------------------------------------------------------------------- */

/*
  Use -DSWIG_DIRECTOR_STATIC if you prefer to avoid the use of the
  'Swig' namespace. This could be useful for multi-modules projects.
*/
#ifdef SWIG_DIRECTOR_STATIC
/* Force anonymous (static) namespace */
#define Swig
#endif
/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes so that D proxy
 * methods can be called from C++.
 * ----------------------------------------------------------------------------- */

#if defined(DEBUG_DIRECTOR_OWNED)
#include <iostream>
#endif
#include <string>
#include <exception>

namespace Swig {

  // Director base class â€“ not used in D directors.
  class Director {
  };

  // Base class for director exceptions.
  class DirectorException : public std::exception {
  protected:
    std::string swig_msg;

  public:
    DirectorException(const std::string &msg) : swig_msg(msg) {
    }

    virtual ~DirectorException() throw() {
    }

    const char *what() const throw() {
      return swig_msg.c_str();
    }
  };

  // Exception which is thrown when attempting to call a pure virtual method
  // from D code through the director layer.
  class DirectorPureVirtualException : public DirectorException {
  public:
    DirectorPureVirtualException(const char *msg) : DirectorException(std::string("Attempted to invoke pure virtual method ") + msg) {
    }
  };
}


#include <string>


#include <stdexcept>


#include <vector>
#include <stdexcept>


#include <stdint.h>		// Use the C99 official header


#include <stdio.h>


#define SWIG
#include "Leap.h"



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "LeapD.h"

SwigDirector_Listener::SwigDirector_Listener() : Leap::Listener(), Swig::Director() {
  swig_init_callbacks();
}

SwigDirector_Listener::~SwigDirector_Listener() {
  
}


void SwigDirector_Listener::onInit(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onInit) {
    Leap::Listener::onInit(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onInit(d_object, jarg0);
  }
}

void SwigDirector_Listener::onConnect(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onConnect) {
    Leap::Listener::onConnect(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onConnect(d_object, jarg0);
  }
}

void SwigDirector_Listener::onDisconnect(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onDisconnect) {
    Leap::Listener::onDisconnect(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onDisconnect(d_object, jarg0);
  }
}

void SwigDirector_Listener::onExit(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onExit) {
    Leap::Listener::onExit(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onExit(d_object, jarg0);
  }
}

void SwigDirector_Listener::onFrame(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onFrame) {
    Leap::Listener::onFrame(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onFrame(d_object, jarg0);
  }
}

void SwigDirector_Listener::onFocusGained(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onFocusGained) {
    Leap::Listener::onFocusGained(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onFocusGained(d_object, jarg0);
  }
}

void SwigDirector_Listener::onFocusLost(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onFocusLost) {
    Leap::Listener::onFocusLost(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onFocusLost(d_object, jarg0);
  }
}

void SwigDirector_Listener::onServiceConnect(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onServiceConnect) {
    Leap::Listener::onServiceConnect(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onServiceConnect(d_object, jarg0);
  }
}

void SwigDirector_Listener::onServiceDisconnect(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onServiceDisconnect) {
    Leap::Listener::onServiceDisconnect(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onServiceDisconnect(d_object, jarg0);
  }
}

void SwigDirector_Listener::onDeviceChange(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onDeviceChange) {
    Leap::Listener::onDeviceChange(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onDeviceChange(d_object, jarg0);
  }
}

void SwigDirector_Listener::onImages(Leap::Controller const &arg0) {
  void * jarg0 = 0 ;
  
  if (!swig_callback_onImages) {
    Leap::Listener::onImages(arg0);
    return;
  } else {
    jarg0 = (Leap::Controller *) &arg0;
    swig_callback_onImages(d_object, jarg0);
  }
}

void SwigDirector_Listener::swig_connect_director(void* dobj, SWIG_Callback0_t callback_onInit, SWIG_Callback1_t callback_onConnect, SWIG_Callback2_t callback_onDisconnect, SWIG_Callback3_t callback_onExit, SWIG_Callback4_t callback_onFrame, SWIG_Callback5_t callback_onFocusGained, SWIG_Callback6_t callback_onFocusLost, SWIG_Callback7_t callback_onServiceConnect, SWIG_Callback8_t callback_onServiceDisconnect, SWIG_Callback9_t callback_onDeviceChange, SWIG_Callback10_t callback_onImages) {
  d_object = dobj;swig_callback_onInit = callback_onInit;
  swig_callback_onConnect = callback_onConnect;
  swig_callback_onDisconnect = callback_onDisconnect;
  swig_callback_onExit = callback_onExit;
  swig_callback_onFrame = callback_onFrame;
  swig_callback_onFocusGained = callback_onFocusGained;
  swig_callback_onFocusLost = callback_onFocusLost;
  swig_callback_onServiceConnect = callback_onServiceConnect;
  swig_callback_onServiceDisconnect = callback_onServiceDisconnect;
  swig_callback_onDeviceChange = callback_onDeviceChange;
  swig_callback_onImages = callback_onImages;
}

void SwigDirector_Listener::swig_init_callbacks() {
  swig_callback_onInit = 0;
  swig_callback_onConnect = 0;
  swig_callback_onDisconnect = 0;
  swig_callback_onExit = 0;
  swig_callback_onFrame = 0;
  swig_callback_onFocusGained = 0;
  swig_callback_onFocusLost = 0;
  swig_callback_onServiceConnect = 0;
  swig_callback_onServiceDisconnect = 0;
  swig_callback_onDeviceChange = 0;
  swig_callback_onImages = 0;
}


#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT float D_PI_get() {
  float jresult ;
  float result;
  
  result = (float)(float)Leap::PI;
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_DEG_TO_RAD_get() {
  float jresult ;
  float result;
  
  result = (float)(float)Leap::DEG_TO_RAD;
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_RAD_TO_DEG_get() {
  float jresult ;
  float result;
  
  result = (float)(float)Leap::RAD_TO_DEG;
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_EPSILON_get() {
  float jresult ;
  float result;
  
  result = (float)(float)Leap::EPSILON;
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_new_Vector__SWIG_0() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *)new Leap::Vector();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Vector__SWIG_1(float jarg1, float jarg2, float jarg3) {
  void * jresult ;
  float arg1 ;
  float arg2 ;
  float arg3 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (float)jarg1;
  arg2 = (float)jarg2;
  arg3 = (float)jarg3;
  result = (Leap::Vector *)new Leap::Vector(arg1,arg2,arg3);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Vector__SWIG_2(void * jarg1) {
  void * jresult ;
  Leap::Vector *arg1 = 0 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (Leap::Vector *)new Leap::Vector((Leap::Vector const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_zero() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::zero();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_xAxis() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::xAxis();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_yAxis() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::yAxis();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_zAxis() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::zAxis();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_left() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::left();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_right() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::right();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_down() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::down();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_up() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::up();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_forward() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::forward();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_backward() {
  void * jresult ;
  Leap::Vector *result = 0 ;
  
  result = (Leap::Vector *) &Leap::Vector::backward();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT float D_Vector_magnitude(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float)((Leap::Vector const *)arg1)->magnitude();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_magnitudeSquared(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float)((Leap::Vector const *)arg1)->magnitudeSquared();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_distanceTo(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (float)((Leap::Vector const *)arg1)->distanceTo((Leap::Vector const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_angleTo(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (float)((Leap::Vector const *)arg1)->angleTo((Leap::Vector const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_pitch(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float)((Leap::Vector const *)arg1)->pitch();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_yaw(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float)((Leap::Vector const *)arg1)->yaw();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_roll(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float)((Leap::Vector const *)arg1)->roll();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_dot(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (float)((Leap::Vector const *)arg1)->dot((Leap::Vector const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Vector_cross(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::Vector const *)arg1)->cross((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Vector_normalized(void * jarg1) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = ((Leap::Vector const *)arg1)->normalized();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpNeg(void * jarg1) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = ((Leap::Vector const *)arg1)->operator -();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpAdd(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::Vector const *)arg1)->operator +((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpSub(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::Vector const *)arg1)->operator -((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpMul(void * jarg1, float jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float arg2 ;
  Leap::Vector result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (float)jarg2;
  result = ((Leap::Vector const *)arg1)->operator *(arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpDiv(void * jarg1, float jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float arg2 ;
  Leap::Vector result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (float)jarg2;
  result = ((Leap::Vector const *)arg1)->operator /(arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpAddAssign(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (Leap::Vector *) &(arg1)->operator +=((Leap::Vector const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpSubAssign(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (Leap::Vector *) &(arg1)->operator -=((Leap::Vector const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpMulAssign(void * jarg1, float jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float arg2 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (float)jarg2;
  result = (Leap::Vector *) &(arg1)->operator *=(arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Vector_swigOpDivAssign(void * jarg1, float jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float arg2 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (float)jarg2;
  result = (Leap::Vector *) &(arg1)->operator /=(arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT char * D_Vector_toString(void * jarg1) {
  char * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  std::string result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = ((Leap::Vector const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned int D_Vector_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  Leap::Vector *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Vector const *)arg1)->operator ==((Leap::Vector const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Vector_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  bool result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (bool)((Leap::Vector const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Vector_opIndex(void * jarg1, unsigned int jarg2) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  unsigned int arg2 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (unsigned int)jarg2;
  result = (float)((Leap::Vector const *)arg1)->operator [](arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Vector_toFloatPointer(void * jarg1) {
  void * jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float *)((Leap::Vector const *)arg1)->toFloatPointer();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_Vector_x_set(void * jarg1, float jarg2) {
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float arg2 ;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (float)jarg2;
  if (arg1) (arg1)->x = arg2;
}


SWIGEXPORT float D_Vector_x_get(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float) ((arg1)->x);
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_Vector_y_set(void * jarg1, float jarg2) {
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float arg2 ;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (float)jarg2;
  if (arg1) (arg1)->y = arg2;
}


SWIGEXPORT float D_Vector_y_get(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float) ((arg1)->y);
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_Vector_z_set(void * jarg1, float jarg2) {
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float arg2 ;
  
  arg1 = (Leap::Vector *)jarg1;
  arg2 = (float)jarg2;
  if (arg1) (arg1)->z = arg2;
}


SWIGEXPORT float D_Vector_z_get(void * jarg1) {
  float jresult ;
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  float result;
  
  arg1 = (Leap::Vector *)jarg1;
  result = (float) ((arg1)->z);
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_delete_Vector(void * jarg1) {
  Leap::Vector *arg1 = (Leap::Vector *) 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_FloatArray_opIndex(void * jarg1, unsigned int jarg2) {
  void * jresult ;
  Leap::FloatArray *arg1 = (Leap::FloatArray *) 0 ;
  unsigned int arg2 ;
  float *result = 0 ;
  
  arg1 = (Leap::FloatArray *)jarg1;
  arg2 = (unsigned int)jarg2;
  result = (float *) &(arg1)->operator [](arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_FloatArray_m_array_set(void * jarg1, void * jarg2) {
  Leap::FloatArray *arg1 = (Leap::FloatArray *) 0 ;
  float *arg2 ;
  
  arg1 = (Leap::FloatArray *)jarg1;
  arg2 = (float *)jarg2; 
  {
    size_t ii;
    float *b = (float *) arg1->m_array;
    for (ii = 0; ii < (size_t)16; ii++) b[ii] = *((float *) arg2 + ii);
  }
}


SWIGEXPORT void * D_FloatArray_m_array_get(void * jarg1) {
  void * jresult ;
  Leap::FloatArray *arg1 = (Leap::FloatArray *) 0 ;
  float *result = 0 ;
  
  arg1 = (Leap::FloatArray *)jarg1;
  result = (float *)(float *) ((arg1)->m_array);
  jresult = result; 
  return jresult;
}


SWIGEXPORT void * D_new_FloatArray() {
  void * jresult ;
  Leap::FloatArray *result = 0 ;
  
  result = (Leap::FloatArray *)new Leap::FloatArray();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_FloatArray(void * jarg1) {
  Leap::FloatArray *arg1 = (Leap::FloatArray *) 0 ;
  
  arg1 = (Leap::FloatArray *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Matrix__SWIG_0() {
  void * jresult ;
  Leap::Matrix *result = 0 ;
  
  result = (Leap::Matrix *)new Leap::Matrix();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Matrix__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = 0 ;
  Leap::Matrix *result = 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Matrix const & type is null");
    return 0;
  } 
  result = (Leap::Matrix *)new Leap::Matrix((Leap::Matrix const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Matrix__SWIG_2(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  Leap::Vector *arg1 = 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector *arg3 = 0 ;
  Leap::Matrix *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (Leap::Matrix *)new Leap::Matrix((Leap::Vector const &)*arg1,(Leap::Vector const &)*arg2,(Leap::Vector const &)*arg3);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Matrix__SWIG_3(void * jarg1, void * jarg2, void * jarg3, void * jarg4) {
  void * jresult ;
  Leap::Vector *arg1 = 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector *arg3 = 0 ;
  Leap::Vector *arg4 = 0 ;
  Leap::Matrix *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg4 = (Leap::Vector *)jarg4;
  if (!arg4) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (Leap::Matrix *)new Leap::Matrix((Leap::Vector const &)*arg1,(Leap::Vector const &)*arg2,(Leap::Vector const &)*arg3,(Leap::Vector const &)*arg4);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Matrix__SWIG_4(void * jarg1, float jarg2) {
  void * jresult ;
  Leap::Vector *arg1 = 0 ;
  float arg2 ;
  Leap::Matrix *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg2 = (float)jarg2;
  result = (Leap::Matrix *)new Leap::Matrix((Leap::Vector const &)*arg1,arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Matrix__SWIG_5(void * jarg1, float jarg2, void * jarg3) {
  void * jresult ;
  Leap::Vector *arg1 = 0 ;
  float arg2 ;
  Leap::Vector *arg3 = 0 ;
  Leap::Matrix *result = 0 ;
  
  arg1 = (Leap::Vector *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg2 = (float)jarg2;
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (Leap::Matrix *)new Leap::Matrix((Leap::Vector const &)*arg1,arg2,(Leap::Vector const &)*arg3);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Matrix_identity() {
  void * jresult ;
  Leap::Matrix *result = 0 ;
  
  result = (Leap::Matrix *) &Leap::Matrix::identity();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_Matrix_setRotation(void * jarg1, void * jarg2, float jarg3) {
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *arg2 = 0 ;
  float arg3 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return ;
  } 
  arg3 = (float)jarg3;
  (arg1)->setRotation((Leap::Vector const &)*arg2,arg3);
}


SWIGEXPORT void * D_Matrix_transformPoint(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::Matrix const *)arg1)->transformPoint((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Matrix_transformDirection(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::Matrix const *)arg1)->transformDirection((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Matrix_rigidInverse(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = ((Leap::Matrix const *)arg1)->rigidInverse();
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * D_Matrix_swigOpMul(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Matrix *arg2 = 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Matrix *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Matrix const & type is null");
    return 0;
  } 
  result = ((Leap::Matrix const *)arg1)->operator *((Leap::Matrix const &)*arg2);
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * D_Matrix_swigOpMulAssign(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Matrix *arg2 = 0 ;
  Leap::Matrix *result = 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Matrix *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Matrix const & type is null");
    return 0;
  } 
  result = (Leap::Matrix *) &(arg1)->operator *=((Leap::Matrix const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Matrix_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Matrix *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Matrix *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Matrix const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Matrix const *)arg1)->operator ==((Leap::Matrix const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Matrix_toArray3x3(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::FloatArray result;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = ((Leap::Matrix const *)arg1)->toArray3x3();
  jresult = new Leap::FloatArray((const Leap::FloatArray &)result); 
  return jresult;
}


SWIGEXPORT void * D_Matrix_toArray4x4(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::FloatArray result;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = ((Leap::Matrix const *)arg1)->toArray4x4();
  jresult = new Leap::FloatArray((const Leap::FloatArray &)result); 
  return jresult;
}


SWIGEXPORT char * D_Matrix_toString(void * jarg1) {
  char * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  std::string result;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = ((Leap::Matrix const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_Matrix_xBasis_set(void * jarg1, void * jarg2) {
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *arg2 = (Leap::Vector *) 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (arg1) (arg1)->xBasis = *arg2;
}


SWIGEXPORT void * D_Matrix_xBasis_get(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = (Leap::Vector *)& ((arg1)->xBasis);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_Matrix_yBasis_set(void * jarg1, void * jarg2) {
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *arg2 = (Leap::Vector *) 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (arg1) (arg1)->yBasis = *arg2;
}


SWIGEXPORT void * D_Matrix_yBasis_get(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = (Leap::Vector *)& ((arg1)->yBasis);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_Matrix_zBasis_set(void * jarg1, void * jarg2) {
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *arg2 = (Leap::Vector *) 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (arg1) (arg1)->zBasis = *arg2;
}


SWIGEXPORT void * D_Matrix_zBasis_get(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = (Leap::Vector *)& ((arg1)->zBasis);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_Matrix_origin_set(void * jarg1, void * jarg2) {
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *arg2 = (Leap::Vector *) 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (arg1) (arg1)->origin = *arg2;
}


SWIGEXPORT void * D_Matrix_origin_get(void * jarg1) {
  void * jresult ;
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  Leap::Vector *result = 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  result = (Leap::Vector *)& ((arg1)->origin);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_Matrix(void * jarg1) {
  Leap::Matrix *arg1 = (Leap::Matrix *) 0 ;
  
  arg1 = (Leap::Matrix *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Pointable() {
  void * jresult ;
  Leap::Pointable *result = 0 ;
  
  result = (Leap::Pointable *)new Leap::Pointable();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_Pointable_id(void * jarg1) {
  int jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  int32_t result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (int32_t)((Leap::Pointable const *)arg1)->id();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Pointable_frame(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  SwigValueWrapper< Leap::Frame > result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = ((Leap::Pointable const *)arg1)->frame();
  jresult = new Leap::Frame((const Leap::Frame &)result); 
  return jresult;
}


SWIGEXPORT void * D_Pointable_hand(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  SwigValueWrapper< Leap::Hand > result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = ((Leap::Pointable const *)arg1)->hand();
  jresult = new Leap::Hand((const Leap::Hand &)result); 
  return jresult;
}


SWIGEXPORT void * D_Pointable_tipPosition(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = ((Leap::Pointable const *)arg1)->tipPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Pointable_tipVelocity(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = ((Leap::Pointable const *)arg1)->tipVelocity();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Pointable_direction(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = ((Leap::Pointable const *)arg1)->direction();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Pointable_width(void * jarg1) {
  float jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  float result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (float)((Leap::Pointable const *)arg1)->width();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Pointable_length(void * jarg1) {
  float jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  float result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (float)((Leap::Pointable const *)arg1)->length();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Pointable_isFinger(void * jarg1) {
  unsigned int jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  bool result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (bool)((Leap::Pointable const *)arg1)->isFinger();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Pointable_isTool(void * jarg1) {
  unsigned int jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  bool result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (bool)((Leap::Pointable const *)arg1)->isTool();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Pointable_isExtended(void * jarg1) {
  unsigned int jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  bool result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (bool)((Leap::Pointable const *)arg1)->isExtended();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Pointable_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  bool result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (bool)((Leap::Pointable const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Pointable_touchZone(void * jarg1) {
  int jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  Leap::Pointable::Zone result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (Leap::Pointable::Zone)((Leap::Pointable const *)arg1)->touchZone();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT float D_Pointable_touchDistance(void * jarg1) {
  float jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  float result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (float)((Leap::Pointable const *)arg1)->touchDistance();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Pointable_stabilizedTipPosition(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = ((Leap::Pointable const *)arg1)->stabilizedTipPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Pointable_timeVisible(void * jarg1) {
  float jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  float result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = (float)((Leap::Pointable const *)arg1)->timeVisible();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Pointable_invalid() {
  void * jresult ;
  Leap::Pointable *result = 0 ;
  
  result = (Leap::Pointable *) &Leap::Pointable::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Pointable_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  Leap::Pointable *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Pointable *)jarg1;
  arg2 = (Leap::Pointable *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Pointable const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Pointable const *)arg1)->operator ==((Leap::Pointable const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Pointable_toString(void * jarg1) {
  char * jresult ;
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  std::string result;
  
  arg1 = (Leap::Pointable *)jarg1;
  result = ((Leap::Pointable const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Pointable(void * jarg1) {
  Leap::Pointable *arg1 = (Leap::Pointable *) 0 ;
  
  arg1 = (Leap::Pointable *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Arm() {
  void * jresult ;
  Leap::Arm *result = 0 ;
  
  result = (Leap::Arm *)new Leap::Arm();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT float D_Arm_width(void * jarg1) {
  float jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  float result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = (float)((Leap::Arm const *)arg1)->width();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Arm_direction(void * jarg1) {
  void * jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = ((Leap::Arm const *)arg1)->direction();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Arm_basis(void * jarg1) {
  void * jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = ((Leap::Arm const *)arg1)->basis();
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * D_Arm_elbowPosition(void * jarg1) {
  void * jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = ((Leap::Arm const *)arg1)->elbowPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Arm_wristPosition(void * jarg1) {
  void * jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = ((Leap::Arm const *)arg1)->wristPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Arm_center(void * jarg1) {
  void * jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = ((Leap::Arm const *)arg1)->center();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT unsigned int D_Arm_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  bool result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = (bool)((Leap::Arm const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Arm_invalid() {
  void * jresult ;
  Leap::Arm *result = 0 ;
  
  result = (Leap::Arm *) &Leap::Arm::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Arm_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  Leap::Arm *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Arm *)jarg1;
  arg2 = (Leap::Arm *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Arm const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Arm const *)arg1)->operator ==((Leap::Arm const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Arm_toString(void * jarg1) {
  char * jresult ;
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  std::string result;
  
  arg1 = (Leap::Arm *)jarg1;
  result = ((Leap::Arm const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Arm(void * jarg1) {
  Leap::Arm *arg1 = (Leap::Arm *) 0 ;
  
  arg1 = (Leap::Arm *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Bone() {
  void * jresult ;
  Leap::Bone *result = 0 ;
  
  result = (Leap::Bone *)new Leap::Bone();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Bone_prevJoint(void * jarg1) {
  void * jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = ((Leap::Bone const *)arg1)->prevJoint();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Bone_nextJoint(void * jarg1) {
  void * jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = ((Leap::Bone const *)arg1)->nextJoint();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Bone_center(void * jarg1) {
  void * jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = ((Leap::Bone const *)arg1)->center();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Bone_direction(void * jarg1) {
  void * jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = ((Leap::Bone const *)arg1)->direction();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Bone_length(void * jarg1) {
  float jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  float result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = (float)((Leap::Bone const *)arg1)->length();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Bone_width(void * jarg1) {
  float jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  float result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = (float)((Leap::Bone const *)arg1)->width();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Bone_type(void * jarg1) {
  int jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  Leap::Bone::Type result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = (Leap::Bone::Type)((Leap::Bone const *)arg1)->type();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * D_Bone_basis(void * jarg1) {
  void * jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = ((Leap::Bone const *)arg1)->basis();
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT unsigned int D_Bone_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  bool result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = (bool)((Leap::Bone const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Bone_invalid() {
  void * jresult ;
  Leap::Bone *result = 0 ;
  
  result = (Leap::Bone *) &Leap::Bone::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Bone_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  Leap::Bone *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Bone *)jarg1;
  arg2 = (Leap::Bone *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Bone const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Bone const *)arg1)->operator ==((Leap::Bone const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Bone_toString(void * jarg1) {
  char * jresult ;
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  std::string result;
  
  arg1 = (Leap::Bone *)jarg1;
  result = ((Leap::Bone const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Bone(void * jarg1) {
  Leap::Bone *arg1 = (Leap::Bone *) 0 ;
  
  arg1 = (Leap::Bone *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Finger__SWIG_0() {
  void * jresult ;
  Leap::Finger *result = 0 ;
  
  result = (Leap::Finger *)new Leap::Finger();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Finger__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = 0 ;
  Leap::Finger *result = 0 ;
  
  arg1 = (Leap::Pointable *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Pointable const & type is null");
    return 0;
  } 
  result = (Leap::Finger *)new Leap::Finger((Leap::Pointable const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Finger_jointPosition(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Finger *arg1 = (Leap::Finger *) 0 ;
  Leap::Finger::Joint arg2 ;
  Leap::Vector result;
  
  arg1 = (Leap::Finger *)jarg1;
  arg2 = (Leap::Finger::Joint)jarg2; 
  result = ((Leap::Finger const *)arg1)->jointPosition(arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Finger_bone(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Finger *arg1 = (Leap::Finger *) 0 ;
  Leap::Bone::Type arg2 ;
  SwigValueWrapper< Leap::Bone > result;
  
  arg1 = (Leap::Finger *)jarg1;
  arg2 = (Leap::Bone::Type)jarg2; 
  result = ((Leap::Finger const *)arg1)->bone(arg2);
  jresult = new Leap::Bone((const Leap::Bone &)result); 
  return jresult;
}


SWIGEXPORT int D_Finger_type(void * jarg1) {
  int jresult ;
  Leap::Finger *arg1 = (Leap::Finger *) 0 ;
  Leap::Finger::Type result;
  
  arg1 = (Leap::Finger *)jarg1;
  result = (Leap::Finger::Type)((Leap::Finger const *)arg1)->type();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * D_Finger_invalid() {
  void * jresult ;
  Leap::Finger *result = 0 ;
  
  result = (Leap::Finger *) &Leap::Finger::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT char * D_Finger_toString(void * jarg1) {
  char * jresult ;
  Leap::Finger *arg1 = (Leap::Finger *) 0 ;
  std::string result;
  
  arg1 = (Leap::Finger *)jarg1;
  result = ((Leap::Finger const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Finger(void * jarg1) {
  Leap::Finger *arg1 = (Leap::Finger *) 0 ;
  
  arg1 = (Leap::Finger *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Tool__SWIG_0() {
  void * jresult ;
  Leap::Tool *result = 0 ;
  
  result = (Leap::Tool *)new Leap::Tool();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Tool__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Pointable *arg1 = 0 ;
  Leap::Tool *result = 0 ;
  
  arg1 = (Leap::Pointable *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Pointable const & type is null");
    return 0;
  } 
  result = (Leap::Tool *)new Leap::Tool((Leap::Pointable const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_Tool_invalid() {
  void * jresult ;
  Leap::Tool *result = 0 ;
  
  result = (Leap::Tool *) &Leap::Tool::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT char * D_Tool_toString(void * jarg1) {
  char * jresult ;
  Leap::Tool *arg1 = (Leap::Tool *) 0 ;
  std::string result;
  
  arg1 = (Leap::Tool *)jarg1;
  result = ((Leap::Tool const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Tool(void * jarg1) {
  Leap::Tool *arg1 = (Leap::Tool *) 0 ;
  
  arg1 = (Leap::Tool *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Hand() {
  void * jresult ;
  Leap::Hand *result = 0 ;
  
  result = (Leap::Hand *)new Leap::Hand();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_Hand_id(void * jarg1) {
  int jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  int32_t result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (int32_t)((Leap::Hand const *)arg1)->id();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Hand_frame(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  SwigValueWrapper< Leap::Frame > result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->frame();
  jresult = new Leap::Frame((const Leap::Frame &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_pointables(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  SwigValueWrapper< Leap::PointableList > result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->pointables();
  jresult = new Leap::PointableList((const Leap::PointableList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_pointable(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  int32_t arg2 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Hand const *)arg1)->pointable(arg2);
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_fingers(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  SwigValueWrapper< Leap::FingerList > result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->fingers();
  jresult = new Leap::FingerList((const Leap::FingerList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_finger(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  int32_t arg2 ;
  Leap::Finger result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Hand const *)arg1)->finger(arg2);
  jresult = new Leap::Finger((const Leap::Finger &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_tools(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  SwigValueWrapper< Leap::ToolList > result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->tools();
  jresult = new Leap::ToolList((const Leap::ToolList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_tool(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  int32_t arg2 ;
  Leap::Tool result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Hand const *)arg1)->tool(arg2);
  jresult = new Leap::Tool((const Leap::Tool &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_palmPosition(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->palmPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_stabilizedPalmPosition(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->stabilizedPalmPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_palmVelocity(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->palmVelocity();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_palmNormal(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->palmNormal();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Hand_palmWidth(void * jarg1) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (float)((Leap::Hand const *)arg1)->palmWidth();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Hand_direction(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->direction();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_basis(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->basis();
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_arm(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  SwigValueWrapper< Leap::Arm > result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->arm();
  jresult = new Leap::Arm((const Leap::Arm &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_wristPosition(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->wristPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Hand_sphereCenter(void * jarg1) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->sphereCenter();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Hand_sphereRadius(void * jarg1) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (float)((Leap::Hand const *)arg1)->sphereRadius();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Hand_pinchStrength(void * jarg1) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (float)((Leap::Hand const *)arg1)->pinchStrength();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Hand_grabStrength(void * jarg1) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (float)((Leap::Hand const *)arg1)->grabStrength();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Hand_translation(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = ((Leap::Hand const *)arg1)->translation((Leap::Frame const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Hand_translationProbability(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Hand const *)arg1)->translationProbability((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Hand_rotationAxis(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = ((Leap::Hand const *)arg1)->rotationAxis((Leap::Frame const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Hand_rotationAngle__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Hand const *)arg1)->rotationAngle((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Hand_rotationAngle__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Vector *arg3 = 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (float)((Leap::Hand const *)arg1)->rotationAngle((Leap::Frame const &)*arg2,(Leap::Vector const &)*arg3);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Hand_rotationMatrix(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = ((Leap::Hand const *)arg1)->rotationMatrix((Leap::Frame const &)*arg2);
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT float D_Hand_rotationProbability(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Hand const *)arg1)->rotationProbability((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Hand_scaleFactor(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Hand const *)arg1)->scaleFactor((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Hand_scaleProbability(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Hand const *)arg1)->scaleProbability((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Hand_timeVisible(void * jarg1) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (float)((Leap::Hand const *)arg1)->timeVisible();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Hand_confidence(void * jarg1) {
  float jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  float result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (float)((Leap::Hand const *)arg1)->confidence();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Hand_isLeft(void * jarg1) {
  unsigned int jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  bool result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (bool)((Leap::Hand const *)arg1)->isLeft();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Hand_isRight(void * jarg1) {
  unsigned int jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  bool result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (bool)((Leap::Hand const *)arg1)->isRight();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Hand_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  bool result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = (bool)((Leap::Hand const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Hand_invalid() {
  void * jresult ;
  Leap::Hand *result = 0 ;
  
  result = (Leap::Hand *) &Leap::Hand::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Hand_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  Leap::Hand *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Hand *)jarg1;
  arg2 = (Leap::Hand *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Hand const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Hand const *)arg1)->operator ==((Leap::Hand const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Hand_toString(void * jarg1) {
  char * jresult ;
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  std::string result;
  
  arg1 = (Leap::Hand *)jarg1;
  result = ((Leap::Hand const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Hand(void * jarg1) {
  Leap::Hand *arg1 = (Leap::Hand *) 0 ;
  
  arg1 = (Leap::Hand *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Gesture__SWIG_0() {
  void * jresult ;
  Leap::Gesture *result = 0 ;
  
  result = (Leap::Gesture *)new Leap::Gesture();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_Gesture__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = 0 ;
  Leap::Gesture *result = 0 ;
  
  arg1 = (Leap::Gesture *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Gesture const & type is null");
    return 0;
  } 
  result = (Leap::Gesture *)new Leap::Gesture((Leap::Gesture const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_Gesture_type(void * jarg1) {
  int jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  Leap::Gesture::Type result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = (Leap::Gesture::Type)((Leap::Gesture const *)arg1)->type();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT int D_Gesture_state(void * jarg1) {
  int jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  Leap::Gesture::State result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = (Leap::Gesture::State)((Leap::Gesture const *)arg1)->state();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT int D_Gesture_id(void * jarg1) {
  int jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  int32_t result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = (int32_t)((Leap::Gesture const *)arg1)->id();
  jresult = result;
  return jresult;
}


SWIGEXPORT long long D_Gesture_duration(void * jarg1) {
  long long jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  int64_t result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = (int64_t)((Leap::Gesture const *)arg1)->duration();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Gesture_durationSeconds(void * jarg1) {
  float jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  float result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = (float)((Leap::Gesture const *)arg1)->durationSeconds();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Gesture_frame(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  SwigValueWrapper< Leap::Frame > result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = ((Leap::Gesture const *)arg1)->frame();
  jresult = new Leap::Frame((const Leap::Frame &)result); 
  return jresult;
}


SWIGEXPORT void * D_Gesture_hands(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  SwigValueWrapper< Leap::HandList > result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = ((Leap::Gesture const *)arg1)->hands();
  jresult = new Leap::HandList((const Leap::HandList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Gesture_pointables(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  SwigValueWrapper< Leap::PointableList > result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = ((Leap::Gesture const *)arg1)->pointables();
  jresult = new Leap::PointableList((const Leap::PointableList &)result); 
  return jresult;
}


SWIGEXPORT unsigned int D_Gesture_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  bool result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = (bool)((Leap::Gesture const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Gesture_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  Leap::Gesture *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Gesture *)jarg1;
  arg2 = (Leap::Gesture *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Gesture const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Gesture const *)arg1)->operator ==((Leap::Gesture const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Gesture_toString(void * jarg1) {
  char * jresult ;
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  std::string result;
  
  arg1 = (Leap::Gesture *)jarg1;
  result = ((Leap::Gesture const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * D_Gesture_invalid() {
  void * jresult ;
  Leap::Gesture *result = 0 ;
  
  result = (Leap::Gesture *) &Leap::Gesture::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_Gesture(void * jarg1) {
  Leap::Gesture *arg1 = (Leap::Gesture *) 0 ;
  
  arg1 = (Leap::Gesture *)jarg1;
  delete arg1;
}


SWIGEXPORT int D_SwipeGesture_classType() {
  int jresult ;
  Leap::Gesture::Type result;
  
  result = (Leap::Gesture::Type)Leap::SwipeGesture::classType();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * D_new_SwipeGesture__SWIG_0() {
  void * jresult ;
  Leap::SwipeGesture *result = 0 ;
  
  result = (Leap::SwipeGesture *)new Leap::SwipeGesture();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_SwipeGesture__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = 0 ;
  Leap::SwipeGesture *result = 0 ;
  
  arg1 = (Leap::Gesture *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Gesture const & type is null");
    return 0;
  } 
  result = (Leap::SwipeGesture *)new Leap::SwipeGesture((Leap::Gesture const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_SwipeGesture_startPosition(void * jarg1) {
  void * jresult ;
  Leap::SwipeGesture *arg1 = (Leap::SwipeGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::SwipeGesture *)jarg1;
  result = ((Leap::SwipeGesture const *)arg1)->startPosition();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_SwipeGesture_position(void * jarg1) {
  void * jresult ;
  Leap::SwipeGesture *arg1 = (Leap::SwipeGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::SwipeGesture *)jarg1;
  result = ((Leap::SwipeGesture const *)arg1)->position();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_SwipeGesture_direction(void * jarg1) {
  void * jresult ;
  Leap::SwipeGesture *arg1 = (Leap::SwipeGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::SwipeGesture *)jarg1;
  result = ((Leap::SwipeGesture const *)arg1)->direction();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_SwipeGesture_speed(void * jarg1) {
  float jresult ;
  Leap::SwipeGesture *arg1 = (Leap::SwipeGesture *) 0 ;
  float result;
  
  arg1 = (Leap::SwipeGesture *)jarg1;
  result = (float)((Leap::SwipeGesture const *)arg1)->speed();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_SwipeGesture_pointable(void * jarg1) {
  void * jresult ;
  Leap::SwipeGesture *arg1 = (Leap::SwipeGesture *) 0 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::SwipeGesture *)jarg1;
  result = ((Leap::SwipeGesture const *)arg1)->pointable();
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_SwipeGesture(void * jarg1) {
  Leap::SwipeGesture *arg1 = (Leap::SwipeGesture *) 0 ;
  
  arg1 = (Leap::SwipeGesture *)jarg1;
  delete arg1;
}


SWIGEXPORT int D_CircleGesture_classType() {
  int jresult ;
  Leap::Gesture::Type result;
  
  result = (Leap::Gesture::Type)Leap::CircleGesture::classType();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * D_new_CircleGesture__SWIG_0() {
  void * jresult ;
  Leap::CircleGesture *result = 0 ;
  
  result = (Leap::CircleGesture *)new Leap::CircleGesture();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_CircleGesture__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = 0 ;
  Leap::CircleGesture *result = 0 ;
  
  arg1 = (Leap::Gesture *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Gesture const & type is null");
    return 0;
  } 
  result = (Leap::CircleGesture *)new Leap::CircleGesture((Leap::Gesture const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_CircleGesture_center(void * jarg1) {
  void * jresult ;
  Leap::CircleGesture *arg1 = (Leap::CircleGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::CircleGesture *)jarg1;
  result = ((Leap::CircleGesture const *)arg1)->center();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_CircleGesture_normal(void * jarg1) {
  void * jresult ;
  Leap::CircleGesture *arg1 = (Leap::CircleGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::CircleGesture *)jarg1;
  result = ((Leap::CircleGesture const *)arg1)->normal();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_CircleGesture_progress(void * jarg1) {
  float jresult ;
  Leap::CircleGesture *arg1 = (Leap::CircleGesture *) 0 ;
  float result;
  
  arg1 = (Leap::CircleGesture *)jarg1;
  result = (float)((Leap::CircleGesture const *)arg1)->progress();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_CircleGesture_radius(void * jarg1) {
  float jresult ;
  Leap::CircleGesture *arg1 = (Leap::CircleGesture *) 0 ;
  float result;
  
  arg1 = (Leap::CircleGesture *)jarg1;
  result = (float)((Leap::CircleGesture const *)arg1)->radius();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_CircleGesture_pointable(void * jarg1) {
  void * jresult ;
  Leap::CircleGesture *arg1 = (Leap::CircleGesture *) 0 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::CircleGesture *)jarg1;
  result = ((Leap::CircleGesture const *)arg1)->pointable();
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_CircleGesture(void * jarg1) {
  Leap::CircleGesture *arg1 = (Leap::CircleGesture *) 0 ;
  
  arg1 = (Leap::CircleGesture *)jarg1;
  delete arg1;
}


SWIGEXPORT int D_ScreenTapGesture_classType() {
  int jresult ;
  Leap::Gesture::Type result;
  
  result = (Leap::Gesture::Type)Leap::ScreenTapGesture::classType();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * D_new_ScreenTapGesture__SWIG_0() {
  void * jresult ;
  Leap::ScreenTapGesture *result = 0 ;
  
  result = (Leap::ScreenTapGesture *)new Leap::ScreenTapGesture();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_ScreenTapGesture__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = 0 ;
  Leap::ScreenTapGesture *result = 0 ;
  
  arg1 = (Leap::Gesture *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Gesture const & type is null");
    return 0;
  } 
  result = (Leap::ScreenTapGesture *)new Leap::ScreenTapGesture((Leap::Gesture const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_ScreenTapGesture_position(void * jarg1) {
  void * jresult ;
  Leap::ScreenTapGesture *arg1 = (Leap::ScreenTapGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::ScreenTapGesture *)jarg1;
  result = ((Leap::ScreenTapGesture const *)arg1)->position();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_ScreenTapGesture_direction(void * jarg1) {
  void * jresult ;
  Leap::ScreenTapGesture *arg1 = (Leap::ScreenTapGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::ScreenTapGesture *)jarg1;
  result = ((Leap::ScreenTapGesture const *)arg1)->direction();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_ScreenTapGesture_progress(void * jarg1) {
  float jresult ;
  Leap::ScreenTapGesture *arg1 = (Leap::ScreenTapGesture *) 0 ;
  float result;
  
  arg1 = (Leap::ScreenTapGesture *)jarg1;
  result = (float)((Leap::ScreenTapGesture const *)arg1)->progress();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_ScreenTapGesture_pointable(void * jarg1) {
  void * jresult ;
  Leap::ScreenTapGesture *arg1 = (Leap::ScreenTapGesture *) 0 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::ScreenTapGesture *)jarg1;
  result = ((Leap::ScreenTapGesture const *)arg1)->pointable();
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_ScreenTapGesture(void * jarg1) {
  Leap::ScreenTapGesture *arg1 = (Leap::ScreenTapGesture *) 0 ;
  
  arg1 = (Leap::ScreenTapGesture *)jarg1;
  delete arg1;
}


SWIGEXPORT int D_KeyTapGesture_classType() {
  int jresult ;
  Leap::Gesture::Type result;
  
  result = (Leap::Gesture::Type)Leap::KeyTapGesture::classType();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void * D_new_KeyTapGesture__SWIG_0() {
  void * jresult ;
  Leap::KeyTapGesture *result = 0 ;
  
  result = (Leap::KeyTapGesture *)new Leap::KeyTapGesture();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_new_KeyTapGesture__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Gesture *arg1 = 0 ;
  Leap::KeyTapGesture *result = 0 ;
  
  arg1 = (Leap::Gesture *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Gesture const & type is null");
    return 0;
  } 
  result = (Leap::KeyTapGesture *)new Leap::KeyTapGesture((Leap::Gesture const &)*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_KeyTapGesture_position(void * jarg1) {
  void * jresult ;
  Leap::KeyTapGesture *arg1 = (Leap::KeyTapGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::KeyTapGesture *)jarg1;
  result = ((Leap::KeyTapGesture const *)arg1)->position();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_KeyTapGesture_direction(void * jarg1) {
  void * jresult ;
  Leap::KeyTapGesture *arg1 = (Leap::KeyTapGesture *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::KeyTapGesture *)jarg1;
  result = ((Leap::KeyTapGesture const *)arg1)->direction();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_KeyTapGesture_progress(void * jarg1) {
  float jresult ;
  Leap::KeyTapGesture *arg1 = (Leap::KeyTapGesture *) 0 ;
  float result;
  
  arg1 = (Leap::KeyTapGesture *)jarg1;
  result = (float)((Leap::KeyTapGesture const *)arg1)->progress();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_KeyTapGesture_pointable(void * jarg1) {
  void * jresult ;
  Leap::KeyTapGesture *arg1 = (Leap::KeyTapGesture *) 0 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::KeyTapGesture *)jarg1;
  result = ((Leap::KeyTapGesture const *)arg1)->pointable();
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_KeyTapGesture(void * jarg1) {
  Leap::KeyTapGesture *arg1 = (Leap::KeyTapGesture *) 0 ;
  
  arg1 = (Leap::KeyTapGesture *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Screen() {
  void * jresult ;
  Leap::Screen *result = 0 ;
  
  result = (Leap::Screen *)new Leap::Screen();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_Screen_id(void * jarg1) {
  int jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  int32_t result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = (int32_t)((Leap::Screen const *)arg1)->id();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Screen_intersect__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3, float jarg4) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Pointable *arg2 = 0 ;
  bool arg3 ;
  float arg4 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Pointable *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Pointable const & type is null");
    return 0;
  } 
  arg3 = jarg3 ? true : false;
  arg4 = (float)jarg4;
  result = ((Leap::Screen const *)arg1)->intersect((Leap::Pointable const &)*arg2,arg3,arg4);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_intersect__SWIG_1(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Pointable *arg2 = 0 ;
  bool arg3 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Pointable *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Pointable const & type is null");
    return 0;
  } 
  arg3 = jarg3 ? true : false;
  result = ((Leap::Screen const *)arg1)->intersect((Leap::Pointable const &)*arg2,arg3);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_intersect__SWIG_2(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4, float jarg5) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector *arg3 = 0 ;
  bool arg4 ;
  float arg5 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg4 = jarg4 ? true : false;
  arg5 = (float)jarg5;
  result = ((Leap::Screen const *)arg1)->intersect((Leap::Vector const &)*arg2,(Leap::Vector const &)*arg3,arg4,arg5);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_intersect__SWIG_3(void * jarg1, void * jarg2, void * jarg3, unsigned int jarg4) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector *arg3 = 0 ;
  bool arg4 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg4 = jarg4 ? true : false;
  result = ((Leap::Screen const *)arg1)->intersect((Leap::Vector const &)*arg2,(Leap::Vector const &)*arg3,arg4);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_project__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3, float jarg4) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector *arg2 = 0 ;
  bool arg3 ;
  float arg4 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = jarg3 ? true : false;
  arg4 = (float)jarg4;
  result = ((Leap::Screen const *)arg1)->project((Leap::Vector const &)*arg2,arg3,arg4);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_project__SWIG_1(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector *arg2 = 0 ;
  bool arg3 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = jarg3 ? true : false;
  result = ((Leap::Screen const *)arg1)->project((Leap::Vector const &)*arg2,arg3);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_horizontalAxis(void * jarg1) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = ((Leap::Screen const *)arg1)->horizontalAxis();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_verticalAxis(void * jarg1) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = ((Leap::Screen const *)arg1)->verticalAxis();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_bottomLeftCorner(void * jarg1) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = ((Leap::Screen const *)arg1)->bottomLeftCorner();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Screen_normal(void * jarg1) {
  void * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = ((Leap::Screen const *)arg1)->normal();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT int D_Screen_widthPixels(void * jarg1) {
  int jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  int result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = (int)((Leap::Screen const *)arg1)->widthPixels();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Screen_heightPixels(void * jarg1) {
  int jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  int result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = (int)((Leap::Screen const *)arg1)->heightPixels();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Screen_distanceToPoint(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Vector *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (float)((Leap::Screen const *)arg1)->distanceToPoint((Leap::Vector const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Screen_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  bool result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = (bool)((Leap::Screen const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Screen_invalid() {
  void * jresult ;
  Leap::Screen *result = 0 ;
  
  result = (Leap::Screen *) &Leap::Screen::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Screen_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  Leap::Screen *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Screen *)jarg1;
  arg2 = (Leap::Screen *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Screen const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Screen const *)arg1)->operator ==((Leap::Screen const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Screen_toString(void * jarg1) {
  char * jresult ;
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  std::string result;
  
  arg1 = (Leap::Screen *)jarg1;
  result = ((Leap::Screen const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Screen(void * jarg1) {
  Leap::Screen *arg1 = (Leap::Screen *) 0 ;
  
  arg1 = (Leap::Screen *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Device() {
  void * jresult ;
  Leap::Device *result = 0 ;
  
  result = (Leap::Device *)new Leap::Device();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT float D_Device_horizontalViewAngle(void * jarg1) {
  float jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  float result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (float)((Leap::Device const *)arg1)->horizontalViewAngle();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Device_verticalViewAngle(void * jarg1) {
  float jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  float result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (float)((Leap::Device const *)arg1)->verticalViewAngle();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Device_range(void * jarg1) {
  float jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  float result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (float)((Leap::Device const *)arg1)->range();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Device_baseline(void * jarg1) {
  float jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  float result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (float)((Leap::Device const *)arg1)->baseline();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Device_distanceToBoundary(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  Leap::Vector *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Device *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (float)((Leap::Device const *)arg1)->distanceToBoundary((Leap::Vector const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Device_isEmbedded(void * jarg1) {
  unsigned int jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  bool result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (bool)((Leap::Device const *)arg1)->isEmbedded();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Device_isStreaming(void * jarg1) {
  unsigned int jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  bool result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (bool)((Leap::Device const *)arg1)->isStreaming();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Device_isFlipped(void * jarg1) {
  unsigned int jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  bool result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (bool)((Leap::Device const *)arg1)->isFlipped();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Device_type(void * jarg1) {
  int jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  Leap::Device::Type result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (Leap::Device::Type)((Leap::Device const *)arg1)->type();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT char * D_Device_serialNumber(void * jarg1) {
  char * jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  std::string result;
  
  arg1 = (Leap::Device *)jarg1;
  result = ((Leap::Device const *)arg1)->serialNumber();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void * D_Device_position(void * jarg1) {
  void * jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Device *)jarg1;
  result = ((Leap::Device const *)arg1)->position();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Device_orientation(void * jarg1) {
  void * jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Device *)jarg1;
  result = ((Leap::Device const *)arg1)->orientation();
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT unsigned int D_Device_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  bool result;
  
  arg1 = (Leap::Device *)jarg1;
  result = (bool)((Leap::Device const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Device_invalid() {
  void * jresult ;
  Leap::Device *result = 0 ;
  
  result = (Leap::Device *) &Leap::Device::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Device_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  Leap::Device *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Device *)jarg1;
  arg2 = (Leap::Device *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Device const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Device const *)arg1)->operator ==((Leap::Device const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Device_toString(void * jarg1) {
  char * jresult ;
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  std::string result;
  
  arg1 = (Leap::Device *)jarg1;
  result = ((Leap::Device const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Device(void * jarg1) {
  Leap::Device *arg1 = (Leap::Device *) 0 ;
  
  arg1 = (Leap::Device *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Image() {
  void * jresult ;
  Leap::Image *result = 0 ;
  
  result = (Leap::Image *)new Leap::Image();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT long long D_Image_sequenceId(void * jarg1) {
  long long jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int64_t result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int64_t)((Leap::Image const *)arg1)->sequenceId();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Image_id(void * jarg1) {
  int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int32_t result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int32_t)((Leap::Image const *)arg1)->id();
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_Image_data(void * jarg1, void * jarg2) {
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = (Leap::Image *)jarg1;
  arg2 = (unsigned char *)jarg2;
  ((Leap::Image const *)arg1)->data(arg2);
}


SWIGEXPORT void D_Image_distortion(void * jarg1, void * jarg2) {
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  float *arg2 = (float *) 0 ;
  
  arg1 = (Leap::Image *)jarg1;
  arg2 = (float *)jarg2;
  ((Leap::Image const *)arg1)->distortion(arg2);
}


SWIGEXPORT int D_Image_width(void * jarg1) {
  int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int)((Leap::Image const *)arg1)->width();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Image_height(void * jarg1) {
  int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int)((Leap::Image const *)arg1)->height();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Image_bytesPerPixel(void * jarg1) {
  int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int)((Leap::Image const *)arg1)->bytesPerPixel();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Image_format(void * jarg1) {
  int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  Leap::Image::FormatType result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (Leap::Image::FormatType)((Leap::Image const *)arg1)->format();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT int D_Image_distortionWidth(void * jarg1) {
  int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int)((Leap::Image const *)arg1)->distortionWidth();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Image_distortionHeight(void * jarg1) {
  int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int)((Leap::Image const *)arg1)->distortionHeight();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Image_rayOffsetX(void * jarg1) {
  float jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  float result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (float)((Leap::Image const *)arg1)->rayOffsetX();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Image_rayOffsetY(void * jarg1) {
  float jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  float result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (float)((Leap::Image const *)arg1)->rayOffsetY();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Image_rayScaleX(void * jarg1) {
  float jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  float result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (float)((Leap::Image const *)arg1)->rayScaleX();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Image_rayScaleY(void * jarg1) {
  float jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  float result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (float)((Leap::Image const *)arg1)->rayScaleY();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Image_rectify(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Image *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::Image const *)arg1)->rectify((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_Image_warp(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Image *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::Image const *)arg1)->warp((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT long long D_Image_timestamp(void * jarg1) {
  long long jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  int64_t result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (int64_t)((Leap::Image const *)arg1)->timestamp();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Image_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  bool result;
  
  arg1 = (Leap::Image *)jarg1;
  result = (bool)((Leap::Image const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Image_invalid() {
  void * jresult ;
  Leap::Image *result = 0 ;
  
  result = (Leap::Image *) &Leap::Image::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Image_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  Leap::Image *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Image *)jarg1;
  arg2 = (Leap::Image *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Image const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Image const *)arg1)->operator ==((Leap::Image const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Image_toString(void * jarg1) {
  char * jresult ;
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  std::string result;
  
  arg1 = (Leap::Image *)jarg1;
  result = ((Leap::Image const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Image(void * jarg1) {
  Leap::Image *arg1 = (Leap::Image *) 0 ;
  
  arg1 = (Leap::Image *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Mask() {
  void * jresult ;
  Leap::Mask *result = 0 ;
  
  result = (Leap::Mask *)new Leap::Mask();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT long long D_Mask_sequenceId(void * jarg1) {
  long long jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  int64_t result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = (int64_t)((Leap::Mask const *)arg1)->sequenceId();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Mask_id(void * jarg1) {
  int jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  int32_t result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = (int32_t)((Leap::Mask const *)arg1)->id();
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_Mask_data(void * jarg1, void * jarg2) {
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = (Leap::Mask *)jarg1;
  arg2 = (unsigned char *)jarg2;
  ((Leap::Mask const *)arg1)->data(arg2);
}


SWIGEXPORT int D_Mask_width(void * jarg1) {
  int jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  int result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = (int)((Leap::Mask const *)arg1)->width();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Mask_height(void * jarg1) {
  int jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  int result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = (int)((Leap::Mask const *)arg1)->height();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Mask_offsetX(void * jarg1) {
  int jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  int result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = (int)((Leap::Mask const *)arg1)->offsetX();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Mask_offsetY(void * jarg1) {
  int jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  int result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = (int)((Leap::Mask const *)arg1)->offsetY();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Mask_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  bool result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = (bool)((Leap::Mask const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Mask_invalid() {
  void * jresult ;
  Leap::Mask *result = 0 ;
  
  result = (Leap::Mask *) &Leap::Mask::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Mask_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  Leap::Mask *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Mask *)jarg1;
  arg2 = (Leap::Mask *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Mask const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Mask const *)arg1)->operator ==((Leap::Mask const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Mask_toString(void * jarg1) {
  char * jresult ;
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  std::string result;
  
  arg1 = (Leap::Mask *)jarg1;
  result = ((Leap::Mask const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Mask(void * jarg1) {
  Leap::Mask *arg1 = (Leap::Mask *) 0 ;
  
  arg1 = (Leap::Mask *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_PointableList() {
  void * jresult ;
  Leap::PointableList *result = 0 ;
  
  result = (Leap::PointableList *)new Leap::PointableList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_PointableList_count(void * jarg1) {
  int jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  int result;
  
  arg1 = (Leap::PointableList *)jarg1;
  result = (int)((Leap::PointableList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_PointableList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  bool result;
  
  arg1 = (Leap::PointableList *)jarg1;
  result = (bool)((Leap::PointableList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_PointableList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::PointableList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::PointableList const *)arg1)->operator [](arg2);
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void * D_PointableList_append__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  Leap::PointableList *arg2 = 0 ;
  Leap::PointableList *result = 0 ;
  
  arg1 = (Leap::PointableList *)jarg1;
  arg2 = (Leap::PointableList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::PointableList const & type is null");
    return 0;
  } 
  result = (Leap::PointableList *) &(arg1)->append((Leap::PointableList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_PointableList_append__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  Leap::FingerList *arg2 = 0 ;
  Leap::PointableList *result = 0 ;
  
  arg1 = (Leap::PointableList *)jarg1;
  arg2 = (Leap::FingerList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::FingerList const & type is null");
    return 0;
  } 
  result = (Leap::PointableList *) &(arg1)->append((Leap::FingerList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_PointableList_append__SWIG_2(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  Leap::ToolList *arg2 = 0 ;
  Leap::PointableList *result = 0 ;
  
  arg1 = (Leap::PointableList *)jarg1;
  arg2 = (Leap::ToolList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::ToolList const & type is null");
    return 0;
  } 
  result = (Leap::PointableList *) &(arg1)->append((Leap::ToolList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_PointableList_leftmost(void * jarg1) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::PointableList *)jarg1;
  result = ((Leap::PointableList const *)arg1)->leftmost();
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void * D_PointableList_rightmost(void * jarg1) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::PointableList *)jarg1;
  result = ((Leap::PointableList const *)arg1)->rightmost();
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void * D_PointableList_frontmost(void * jarg1) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::PointableList *)jarg1;
  result = ((Leap::PointableList const *)arg1)->frontmost();
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void * D_PointableList_extended(void * jarg1) {
  void * jresult ;
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  SwigValueWrapper< Leap::PointableList > result;
  
  arg1 = (Leap::PointableList *)jarg1;
  result = ((Leap::PointableList const *)arg1)->extended();
  jresult = new Leap::PointableList((const Leap::PointableList &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_PointableList(void * jarg1) {
  Leap::PointableList *arg1 = (Leap::PointableList *) 0 ;
  
  arg1 = (Leap::PointableList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_FingerList() {
  void * jresult ;
  Leap::FingerList *result = 0 ;
  
  result = (Leap::FingerList *)new Leap::FingerList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_FingerList_count(void * jarg1) {
  int jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  int result;
  
  arg1 = (Leap::FingerList *)jarg1;
  result = (int)((Leap::FingerList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_FingerList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  bool result;
  
  arg1 = (Leap::FingerList *)jarg1;
  result = (bool)((Leap::FingerList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_FingerList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  int arg2 ;
  Leap::Finger result;
  
  arg1 = (Leap::FingerList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::FingerList const *)arg1)->operator [](arg2);
  jresult = new Leap::Finger((const Leap::Finger &)result); 
  return jresult;
}


SWIGEXPORT void * D_FingerList_append(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  Leap::FingerList *arg2 = 0 ;
  Leap::FingerList *result = 0 ;
  
  arg1 = (Leap::FingerList *)jarg1;
  arg2 = (Leap::FingerList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::FingerList const & type is null");
    return 0;
  } 
  result = (Leap::FingerList *) &(arg1)->append((Leap::FingerList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_FingerList_leftmost(void * jarg1) {
  void * jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  Leap::Finger result;
  
  arg1 = (Leap::FingerList *)jarg1;
  result = ((Leap::FingerList const *)arg1)->leftmost();
  jresult = new Leap::Finger((const Leap::Finger &)result); 
  return jresult;
}


SWIGEXPORT void * D_FingerList_rightmost(void * jarg1) {
  void * jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  Leap::Finger result;
  
  arg1 = (Leap::FingerList *)jarg1;
  result = ((Leap::FingerList const *)arg1)->rightmost();
  jresult = new Leap::Finger((const Leap::Finger &)result); 
  return jresult;
}


SWIGEXPORT void * D_FingerList_frontmost(void * jarg1) {
  void * jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  Leap::Finger result;
  
  arg1 = (Leap::FingerList *)jarg1;
  result = ((Leap::FingerList const *)arg1)->frontmost();
  jresult = new Leap::Finger((const Leap::Finger &)result); 
  return jresult;
}


SWIGEXPORT void * D_FingerList_extended(void * jarg1) {
  void * jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  SwigValueWrapper< Leap::FingerList > result;
  
  arg1 = (Leap::FingerList *)jarg1;
  result = ((Leap::FingerList const *)arg1)->extended();
  jresult = new Leap::FingerList((const Leap::FingerList &)result); 
  return jresult;
}


SWIGEXPORT void * D_FingerList_fingerType(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  Leap::Finger::Type arg2 ;
  SwigValueWrapper< Leap::FingerList > result;
  
  arg1 = (Leap::FingerList *)jarg1;
  arg2 = (Leap::Finger::Type)jarg2; 
  result = ((Leap::FingerList const *)arg1)->fingerType(arg2);
  jresult = new Leap::FingerList((const Leap::FingerList &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_FingerList(void * jarg1) {
  Leap::FingerList *arg1 = (Leap::FingerList *) 0 ;
  
  arg1 = (Leap::FingerList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_ToolList() {
  void * jresult ;
  Leap::ToolList *result = 0 ;
  
  result = (Leap::ToolList *)new Leap::ToolList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_ToolList_count(void * jarg1) {
  int jresult ;
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  int result;
  
  arg1 = (Leap::ToolList *)jarg1;
  result = (int)((Leap::ToolList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_ToolList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  bool result;
  
  arg1 = (Leap::ToolList *)jarg1;
  result = (bool)((Leap::ToolList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_ToolList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  int arg2 ;
  Leap::Tool result;
  
  arg1 = (Leap::ToolList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::ToolList const *)arg1)->operator [](arg2);
  jresult = new Leap::Tool((const Leap::Tool &)result); 
  return jresult;
}


SWIGEXPORT void * D_ToolList_append(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  Leap::ToolList *arg2 = 0 ;
  Leap::ToolList *result = 0 ;
  
  arg1 = (Leap::ToolList *)jarg1;
  arg2 = (Leap::ToolList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::ToolList const & type is null");
    return 0;
  } 
  result = (Leap::ToolList *) &(arg1)->append((Leap::ToolList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_ToolList_leftmost(void * jarg1) {
  void * jresult ;
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  Leap::Tool result;
  
  arg1 = (Leap::ToolList *)jarg1;
  result = ((Leap::ToolList const *)arg1)->leftmost();
  jresult = new Leap::Tool((const Leap::Tool &)result); 
  return jresult;
}


SWIGEXPORT void * D_ToolList_rightmost(void * jarg1) {
  void * jresult ;
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  Leap::Tool result;
  
  arg1 = (Leap::ToolList *)jarg1;
  result = ((Leap::ToolList const *)arg1)->rightmost();
  jresult = new Leap::Tool((const Leap::Tool &)result); 
  return jresult;
}


SWIGEXPORT void * D_ToolList_frontmost(void * jarg1) {
  void * jresult ;
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  Leap::Tool result;
  
  arg1 = (Leap::ToolList *)jarg1;
  result = ((Leap::ToolList const *)arg1)->frontmost();
  jresult = new Leap::Tool((const Leap::Tool &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_ToolList(void * jarg1) {
  Leap::ToolList *arg1 = (Leap::ToolList *) 0 ;
  
  arg1 = (Leap::ToolList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_HandList() {
  void * jresult ;
  Leap::HandList *result = 0 ;
  
  result = (Leap::HandList *)new Leap::HandList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_HandList_count(void * jarg1) {
  int jresult ;
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  int result;
  
  arg1 = (Leap::HandList *)jarg1;
  result = (int)((Leap::HandList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_HandList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  bool result;
  
  arg1 = (Leap::HandList *)jarg1;
  result = (bool)((Leap::HandList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_HandList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Hand > result;
  
  arg1 = (Leap::HandList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::HandList const *)arg1)->operator [](arg2);
  jresult = new Leap::Hand((const Leap::Hand &)result); 
  return jresult;
}


SWIGEXPORT void * D_HandList_append(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  Leap::HandList *arg2 = 0 ;
  Leap::HandList *result = 0 ;
  
  arg1 = (Leap::HandList *)jarg1;
  arg2 = (Leap::HandList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::HandList const & type is null");
    return 0;
  } 
  result = (Leap::HandList *) &(arg1)->append((Leap::HandList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_HandList_leftmost(void * jarg1) {
  void * jresult ;
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  SwigValueWrapper< Leap::Hand > result;
  
  arg1 = (Leap::HandList *)jarg1;
  result = ((Leap::HandList const *)arg1)->leftmost();
  jresult = new Leap::Hand((const Leap::Hand &)result); 
  return jresult;
}


SWIGEXPORT void * D_HandList_rightmost(void * jarg1) {
  void * jresult ;
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  SwigValueWrapper< Leap::Hand > result;
  
  arg1 = (Leap::HandList *)jarg1;
  result = ((Leap::HandList const *)arg1)->rightmost();
  jresult = new Leap::Hand((const Leap::Hand &)result); 
  return jresult;
}


SWIGEXPORT void * D_HandList_frontmost(void * jarg1) {
  void * jresult ;
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  SwigValueWrapper< Leap::Hand > result;
  
  arg1 = (Leap::HandList *)jarg1;
  result = ((Leap::HandList const *)arg1)->frontmost();
  jresult = new Leap::Hand((const Leap::Hand &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_HandList(void * jarg1) {
  Leap::HandList *arg1 = (Leap::HandList *) 0 ;
  
  arg1 = (Leap::HandList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_GestureList() {
  void * jresult ;
  Leap::GestureList *result = 0 ;
  
  result = (Leap::GestureList *)new Leap::GestureList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_GestureList_count(void * jarg1) {
  int jresult ;
  Leap::GestureList *arg1 = (Leap::GestureList *) 0 ;
  int result;
  
  arg1 = (Leap::GestureList *)jarg1;
  result = (int)((Leap::GestureList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_GestureList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::GestureList *arg1 = (Leap::GestureList *) 0 ;
  bool result;
  
  arg1 = (Leap::GestureList *)jarg1;
  result = (bool)((Leap::GestureList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_GestureList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::GestureList *arg1 = (Leap::GestureList *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Gesture > result;
  
  arg1 = (Leap::GestureList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::GestureList const *)arg1)->operator [](arg2);
  jresult = new Leap::Gesture((const Leap::Gesture &)result); 
  return jresult;
}


SWIGEXPORT void * D_GestureList_append(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::GestureList *arg1 = (Leap::GestureList *) 0 ;
  Leap::GestureList *arg2 = 0 ;
  Leap::GestureList *result = 0 ;
  
  arg1 = (Leap::GestureList *)jarg1;
  arg2 = (Leap::GestureList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::GestureList const & type is null");
    return 0;
  } 
  result = (Leap::GestureList *) &(arg1)->append((Leap::GestureList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_GestureList(void * jarg1) {
  Leap::GestureList *arg1 = (Leap::GestureList *) 0 ;
  
  arg1 = (Leap::GestureList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_ScreenList() {
  void * jresult ;
  Leap::ScreenList *result = 0 ;
  
  result = (Leap::ScreenList *)new Leap::ScreenList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_ScreenList_count(void * jarg1) {
  int jresult ;
  Leap::ScreenList *arg1 = (Leap::ScreenList *) 0 ;
  int result;
  
  arg1 = (Leap::ScreenList *)jarg1;
  result = (int)((Leap::ScreenList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_ScreenList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::ScreenList *arg1 = (Leap::ScreenList *) 0 ;
  bool result;
  
  arg1 = (Leap::ScreenList *)jarg1;
  result = (bool)((Leap::ScreenList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_ScreenList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::ScreenList *arg1 = (Leap::ScreenList *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Screen > result;
  
  arg1 = (Leap::ScreenList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::ScreenList const *)arg1)->operator [](arg2);
  jresult = new Leap::Screen((const Leap::Screen &)result); 
  return jresult;
}


SWIGEXPORT void * D_ScreenList_closestScreenHit__SWIG_0(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::ScreenList *arg1 = (Leap::ScreenList *) 0 ;
  Leap::Pointable *arg2 = 0 ;
  SwigValueWrapper< Leap::Screen > result;
  
  arg1 = (Leap::ScreenList *)jarg1;
  arg2 = (Leap::Pointable *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Pointable const & type is null");
    return 0;
  } 
  result = ((Leap::ScreenList const *)arg1)->closestScreenHit((Leap::Pointable const &)*arg2);
  jresult = new Leap::Screen((const Leap::Screen &)result); 
  return jresult;
}


SWIGEXPORT void * D_ScreenList_closestScreenHit__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  void * jresult ;
  Leap::ScreenList *arg1 = (Leap::ScreenList *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector *arg3 = 0 ;
  SwigValueWrapper< Leap::Screen > result;
  
  arg1 = (Leap::ScreenList *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::ScreenList const *)arg1)->closestScreenHit((Leap::Vector const &)*arg2,(Leap::Vector const &)*arg3);
  jresult = new Leap::Screen((const Leap::Screen &)result); 
  return jresult;
}


SWIGEXPORT void * D_ScreenList_closestScreen(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::ScreenList *arg1 = (Leap::ScreenList *) 0 ;
  Leap::Vector *arg2 = 0 ;
  SwigValueWrapper< Leap::Screen > result;
  
  arg1 = (Leap::ScreenList *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::ScreenList const *)arg1)->closestScreen((Leap::Vector const &)*arg2);
  jresult = new Leap::Screen((const Leap::Screen &)result); 
  return jresult;
}


SWIGEXPORT void D_delete_ScreenList(void * jarg1) {
  Leap::ScreenList *arg1 = (Leap::ScreenList *) 0 ;
  
  arg1 = (Leap::ScreenList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_DeviceList() {
  void * jresult ;
  Leap::DeviceList *result = 0 ;
  
  result = (Leap::DeviceList *)new Leap::DeviceList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_DeviceList_count(void * jarg1) {
  int jresult ;
  Leap::DeviceList *arg1 = (Leap::DeviceList *) 0 ;
  int result;
  
  arg1 = (Leap::DeviceList *)jarg1;
  result = (int)((Leap::DeviceList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_DeviceList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::DeviceList *arg1 = (Leap::DeviceList *) 0 ;
  bool result;
  
  arg1 = (Leap::DeviceList *)jarg1;
  result = (bool)((Leap::DeviceList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_DeviceList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::DeviceList *arg1 = (Leap::DeviceList *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Device > result;
  
  arg1 = (Leap::DeviceList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::DeviceList const *)arg1)->operator [](arg2);
  jresult = new Leap::Device((const Leap::Device &)result); 
  return jresult;
}


SWIGEXPORT void * D_DeviceList_append(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::DeviceList *arg1 = (Leap::DeviceList *) 0 ;
  Leap::DeviceList *arg2 = 0 ;
  Leap::DeviceList *result = 0 ;
  
  arg1 = (Leap::DeviceList *)jarg1;
  arg2 = (Leap::DeviceList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::DeviceList const & type is null");
    return 0;
  } 
  result = (Leap::DeviceList *) &(arg1)->append((Leap::DeviceList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_DeviceList(void * jarg1) {
  Leap::DeviceList *arg1 = (Leap::DeviceList *) 0 ;
  
  arg1 = (Leap::DeviceList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_ImageList() {
  void * jresult ;
  Leap::ImageList *result = 0 ;
  
  result = (Leap::ImageList *)new Leap::ImageList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_ImageList_count(void * jarg1) {
  int jresult ;
  Leap::ImageList *arg1 = (Leap::ImageList *) 0 ;
  int result;
  
  arg1 = (Leap::ImageList *)jarg1;
  result = (int)((Leap::ImageList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_ImageList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::ImageList *arg1 = (Leap::ImageList *) 0 ;
  bool result;
  
  arg1 = (Leap::ImageList *)jarg1;
  result = (bool)((Leap::ImageList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_ImageList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::ImageList *arg1 = (Leap::ImageList *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Image > result;
  
  arg1 = (Leap::ImageList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::ImageList const *)arg1)->operator [](arg2);
  jresult = new Leap::Image((const Leap::Image &)result); 
  return jresult;
}


SWIGEXPORT void * D_ImageList_append(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::ImageList *arg1 = (Leap::ImageList *) 0 ;
  Leap::ImageList *arg2 = 0 ;
  Leap::ImageList *result = 0 ;
  
  arg1 = (Leap::ImageList *)jarg1;
  arg2 = (Leap::ImageList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::ImageList const & type is null");
    return 0;
  } 
  result = (Leap::ImageList *) &(arg1)->append((Leap::ImageList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_ImageList(void * jarg1) {
  Leap::ImageList *arg1 = (Leap::ImageList *) 0 ;
  
  arg1 = (Leap::ImageList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_TrackedQuad() {
  void * jresult ;
  Leap::TrackedQuad *result = 0 ;
  
  result = (Leap::TrackedQuad *)new Leap::TrackedQuad();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT float D_TrackedQuad_width(void * jarg1) {
  float jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  float result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = (float)((Leap::TrackedQuad const *)arg1)->width();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_TrackedQuad_height(void * jarg1) {
  float jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  float result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = (float)((Leap::TrackedQuad const *)arg1)->height();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_TrackedQuad_resolutionX(void * jarg1) {
  int jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  int result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = (int)((Leap::TrackedQuad const *)arg1)->resolutionX();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_TrackedQuad_resolutionY(void * jarg1) {
  int jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  int result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = (int)((Leap::TrackedQuad const *)arg1)->resolutionY();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_TrackedQuad_visible(void * jarg1) {
  unsigned int jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  bool result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = (bool)((Leap::TrackedQuad const *)arg1)->visible();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_TrackedQuad_orientation(void * jarg1) {
  void * jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = ((Leap::TrackedQuad const *)arg1)->orientation();
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT void * D_TrackedQuad_position(void * jarg1) {
  void * jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = ((Leap::TrackedQuad const *)arg1)->position();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_TrackedQuad_masks(void * jarg1) {
  void * jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  SwigValueWrapper< Leap::MaskList > result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = ((Leap::TrackedQuad const *)arg1)->masks();
  jresult = new Leap::MaskList((const Leap::MaskList &)result); 
  return jresult;
}


SWIGEXPORT void * D_TrackedQuad_images(void * jarg1) {
  void * jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  SwigValueWrapper< Leap::ImageList > result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = ((Leap::TrackedQuad const *)arg1)->images();
  jresult = new Leap::ImageList((const Leap::ImageList &)result); 
  return jresult;
}


SWIGEXPORT unsigned int D_TrackedQuad_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  bool result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = (bool)((Leap::TrackedQuad const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_TrackedQuad_invalid() {
  void * jresult ;
  Leap::TrackedQuad *result = 0 ;
  
  result = (Leap::TrackedQuad *) &Leap::TrackedQuad::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_TrackedQuad_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  Leap::TrackedQuad *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  arg2 = (Leap::TrackedQuad *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::TrackedQuad const & type is null");
    return 0;
  } 
  result = (bool)((Leap::TrackedQuad const *)arg1)->operator ==((Leap::TrackedQuad const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_TrackedQuad_toString(void * jarg1) {
  char * jresult ;
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  std::string result;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  result = ((Leap::TrackedQuad const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_TrackedQuad(void * jarg1) {
  Leap::TrackedQuad *arg1 = (Leap::TrackedQuad *) 0 ;
  
  arg1 = (Leap::TrackedQuad *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_MaskList() {
  void * jresult ;
  Leap::MaskList *result = 0 ;
  
  result = (Leap::MaskList *)new Leap::MaskList();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_MaskList_count(void * jarg1) {
  int jresult ;
  Leap::MaskList *arg1 = (Leap::MaskList *) 0 ;
  int result;
  
  arg1 = (Leap::MaskList *)jarg1;
  result = (int)((Leap::MaskList const *)arg1)->count();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_MaskList_isEmpty(void * jarg1) {
  unsigned int jresult ;
  Leap::MaskList *arg1 = (Leap::MaskList *) 0 ;
  bool result;
  
  arg1 = (Leap::MaskList *)jarg1;
  result = (bool)((Leap::MaskList const *)arg1)->isEmpty();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_MaskList_opIndex(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::MaskList *arg1 = (Leap::MaskList *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Mask > result;
  
  arg1 = (Leap::MaskList *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::MaskList const *)arg1)->operator [](arg2);
  jresult = new Leap::Mask((const Leap::Mask &)result); 
  return jresult;
}


SWIGEXPORT void * D_MaskList_append(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::MaskList *arg1 = (Leap::MaskList *) 0 ;
  Leap::MaskList *arg2 = 0 ;
  Leap::MaskList *result = 0 ;
  
  arg1 = (Leap::MaskList *)jarg1;
  arg2 = (Leap::MaskList *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::MaskList const & type is null");
    return 0;
  } 
  result = (Leap::MaskList *) &(arg1)->append((Leap::MaskList const &)*arg2);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_MaskList(void * jarg1) {
  Leap::MaskList *arg1 = (Leap::MaskList *) 0 ;
  
  arg1 = (Leap::MaskList *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_InteractionBox() {
  void * jresult ;
  Leap::InteractionBox *result = 0 ;
  
  result = (Leap::InteractionBox *)new Leap::InteractionBox();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void * D_InteractionBox_normalizePoint__SWIG_0(void * jarg1, void * jarg2, unsigned int jarg3) {
  void * jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  Leap::Vector *arg2 = 0 ;
  bool arg3 ;
  Leap::Vector result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  arg3 = jarg3 ? true : false;
  result = ((Leap::InteractionBox const *)arg1)->normalizePoint((Leap::Vector const &)*arg2,arg3);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_InteractionBox_normalizePoint__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::InteractionBox const *)arg1)->normalizePoint((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_InteractionBox_denormalizePoint(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  Leap::Vector *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  arg2 = (Leap::Vector *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = ((Leap::InteractionBox const *)arg1)->denormalizePoint((Leap::Vector const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT void * D_InteractionBox_center(void * jarg1) {
  void * jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  result = ((Leap::InteractionBox const *)arg1)->center();
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_InteractionBox_width(void * jarg1) {
  float jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  float result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  result = (float)((Leap::InteractionBox const *)arg1)->width();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_InteractionBox_height(void * jarg1) {
  float jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  float result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  result = (float)((Leap::InteractionBox const *)arg1)->height();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_InteractionBox_depth(void * jarg1) {
  float jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  float result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  result = (float)((Leap::InteractionBox const *)arg1)->depth();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_InteractionBox_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  bool result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  result = (bool)((Leap::InteractionBox const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_InteractionBox_invalid() {
  void * jresult ;
  Leap::InteractionBox *result = 0 ;
  
  result = (Leap::InteractionBox *) &Leap::InteractionBox::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_InteractionBox_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  Leap::InteractionBox *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  arg2 = (Leap::InteractionBox *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::InteractionBox const & type is null");
    return 0;
  } 
  result = (bool)((Leap::InteractionBox const *)arg1)->operator ==((Leap::InteractionBox const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_InteractionBox_toString(void * jarg1) {
  char * jresult ;
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  std::string result;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  result = ((Leap::InteractionBox const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_InteractionBox(void * jarg1) {
  Leap::InteractionBox *arg1 = (Leap::InteractionBox *) 0 ;
  
  arg1 = (Leap::InteractionBox *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Frame() {
  void * jresult ;
  Leap::Frame *result = 0 ;
  
  result = (Leap::Frame *)new Leap::Frame();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT long long D_Frame_id(void * jarg1) {
  long long jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int64_t result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = (int64_t)((Leap::Frame const *)arg1)->id();
  jresult = result;
  return jresult;
}


SWIGEXPORT long long D_Frame_timestamp(void * jarg1) {
  long long jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int64_t result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = (int64_t)((Leap::Frame const *)arg1)->timestamp();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Frame_hands(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::HandList > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->hands();
  jresult = new Leap::HandList((const Leap::HandList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_hand(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int32_t arg2 ;
  SwigValueWrapper< Leap::Hand > result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Frame const *)arg1)->hand(arg2);
  jresult = new Leap::Hand((const Leap::Hand &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_pointables(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::PointableList > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->pointables();
  jresult = new Leap::PointableList((const Leap::PointableList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_pointable(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int32_t arg2 ;
  SwigValueWrapper< Leap::Pointable > result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Frame const *)arg1)->pointable(arg2);
  jresult = new Leap::Pointable((const Leap::Pointable &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_fingers(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::FingerList > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->fingers();
  jresult = new Leap::FingerList((const Leap::FingerList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_finger(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int32_t arg2 ;
  Leap::Finger result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Frame const *)arg1)->finger(arg2);
  jresult = new Leap::Finger((const Leap::Finger &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_tools(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::ToolList > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->tools();
  jresult = new Leap::ToolList((const Leap::ToolList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_tool(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int32_t arg2 ;
  Leap::Tool result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Frame const *)arg1)->tool(arg2);
  jresult = new Leap::Tool((const Leap::Tool &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_gesture(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int32_t arg2 ;
  SwigValueWrapper< Leap::Gesture > result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (int32_t)jarg2;
  result = ((Leap::Frame const *)arg1)->gesture(arg2);
  jresult = new Leap::Gesture((const Leap::Gesture &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_gestures__SWIG_0(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::GestureList > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->gestures();
  jresult = new Leap::GestureList((const Leap::GestureList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_gestures__SWIG_1(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  SwigValueWrapper< Leap::GestureList > result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = ((Leap::Frame const *)arg1)->gestures((Leap::Frame const &)*arg2);
  jresult = new Leap::GestureList((const Leap::GestureList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_images(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::ImageList > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->images();
  jresult = new Leap::ImageList((const Leap::ImageList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Frame_translation(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = ((Leap::Frame const *)arg1)->translation((Leap::Frame const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Frame_translationProbability(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Frame const *)arg1)->translationProbability((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Frame_rotationAxis(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Vector result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = ((Leap::Frame const *)arg1)->rotationAxis((Leap::Frame const &)*arg2);
  jresult = new Leap::Vector((const Leap::Vector &)result); 
  return jresult;
}


SWIGEXPORT float D_Frame_rotationAngle__SWIG_0(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Frame const *)arg1)->rotationAngle((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Frame_rotationAngle__SWIG_1(void * jarg1, void * jarg2, void * jarg3) {
  float jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Vector *arg3 = 0 ;
  float result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  arg3 = (Leap::Vector *)jarg3;
  if (!arg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Vector const & type is null");
    return 0;
  } 
  result = (float)((Leap::Frame const *)arg1)->rotationAngle((Leap::Frame const &)*arg2,(Leap::Vector const &)*arg3);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Frame_rotationMatrix(void * jarg1, void * jarg2) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  Leap::Matrix result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = ((Leap::Frame const *)arg1)->rotationMatrix((Leap::Frame const &)*arg2);
  jresult = new Leap::Matrix((const Leap::Matrix &)result); 
  return jresult;
}


SWIGEXPORT float D_Frame_rotationProbability(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Frame const *)arg1)->rotationProbability((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Frame_scaleFactor(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Frame const *)arg1)->scaleFactor((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Frame_scaleProbability(void * jarg1, void * jarg2) {
  float jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (float)((Leap::Frame const *)arg1)->scaleProbability((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Frame_interactionBox(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::InteractionBox > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->interactionBox();
  jresult = new Leap::InteractionBox((const Leap::InteractionBox &)result); 
  return jresult;
}


SWIGEXPORT float D_Frame_currentFramesPerSecond(void * jarg1) {
  float jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  float result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = (float)((Leap::Frame const *)arg1)->currentFramesPerSecond();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Frame_isValid(void * jarg1) {
  unsigned int jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  bool result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = (bool)((Leap::Frame const *)arg1)->isValid();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Frame_invalid() {
  void * jresult ;
  Leap::Frame *result = 0 ;
  
  result = (Leap::Frame *) &Leap::Frame::invalid();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Frame_swigOpEquals(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  Leap::Frame *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (Leap::Frame *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Frame const & type is null");
    return 0;
  } 
  result = (bool)((Leap::Frame const *)arg1)->operator ==((Leap::Frame const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Frame_trackedQuad(void * jarg1) {
  void * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  SwigValueWrapper< Leap::TrackedQuad > result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->trackedQuad();
  jresult = new Leap::TrackedQuad((const Leap::TrackedQuad &)result); 
  return jresult;
}


SWIGEXPORT void D_Frame_serialize(void * jarg1, void * jarg2) {
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (unsigned char *)jarg2;
  ((Leap::Frame const *)arg1)->serialize(arg2);
}


SWIGEXPORT int D_Frame_serializeLength(void * jarg1) {
  int jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  int result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = (int)((Leap::Frame const *)arg1)->serializeLength();
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_Frame_deserialize(void * jarg1, void * jarg2, int jarg3) {
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  unsigned char *arg2 = (unsigned char *) 0 ;
  int arg3 ;
  
  arg1 = (Leap::Frame *)jarg1;
  arg2 = (unsigned char *)jarg2;
  arg3 = (int)jarg3;
  (arg1)->deserialize((unsigned char const *)arg2,arg3);
}


SWIGEXPORT char * D_Frame_toString(void * jarg1) {
  char * jresult ;
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  std::string result;
  
  arg1 = (Leap::Frame *)jarg1;
  result = ((Leap::Frame const *)arg1)->toString();
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void D_delete_Frame(void * jarg1) {
  Leap::Frame *arg1 = (Leap::Frame *) 0 ;
  
  arg1 = (Leap::Frame *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_BugReport() {
  void * jresult ;
  Leap::BugReport *result = 0 ;
  
  result = (Leap::BugReport *)new Leap::BugReport();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_BugReport_beginRecording(void * jarg1) {
  unsigned int jresult ;
  Leap::BugReport *arg1 = (Leap::BugReport *) 0 ;
  bool result;
  
  arg1 = (Leap::BugReport *)jarg1;
  result = (bool)(arg1)->beginRecording();
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_BugReport_endRecording(void * jarg1) {
  Leap::BugReport *arg1 = (Leap::BugReport *) 0 ;
  
  arg1 = (Leap::BugReport *)jarg1;
  (arg1)->endRecording();
}


SWIGEXPORT unsigned int D_BugReport_isActive(void * jarg1) {
  unsigned int jresult ;
  Leap::BugReport *arg1 = (Leap::BugReport *) 0 ;
  bool result;
  
  arg1 = (Leap::BugReport *)jarg1;
  result = (bool)((Leap::BugReport const *)arg1)->isActive();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_BugReport_progress(void * jarg1) {
  float jresult ;
  Leap::BugReport *arg1 = (Leap::BugReport *) 0 ;
  float result;
  
  arg1 = (Leap::BugReport *)jarg1;
  result = (float)((Leap::BugReport const *)arg1)->progress();
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_BugReport_duration(void * jarg1) {
  float jresult ;
  Leap::BugReport *arg1 = (Leap::BugReport *) 0 ;
  float result;
  
  arg1 = (Leap::BugReport *)jarg1;
  result = (float)((Leap::BugReport const *)arg1)->duration();
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_delete_BugReport(void * jarg1) {
  Leap::BugReport *arg1 = (Leap::BugReport *) 0 ;
  
  arg1 = (Leap::BugReport *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Config() {
  void * jresult ;
  Leap::Config *result = 0 ;
  
  result = (Leap::Config *)new Leap::Config();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT int D_Config_type(void * jarg1, char * jarg2) {
  int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  Leap::Config::ValueType result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (Leap::Config::ValueType)((Leap::Config const *)arg1)->type((std::string const &)*arg2);
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT unsigned int D_Config_getBool(void * jarg1, char * jarg2) {
  unsigned int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (bool)((Leap::Config const *)arg1)->getBool((std::string const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Config_setBool(void * jarg1, char * jarg2, unsigned int jarg3) {
  unsigned int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  bool result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = jarg3 ? true : false;
  result = (bool)(arg1)->setBool((std::string const &)*arg2,arg3);
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Config_getInt32(void * jarg1, char * jarg2) {
  int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  int32_t result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (int32_t)((Leap::Config const *)arg1)->getInt32((std::string const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Config_setInt32(void * jarg1, char * jarg2, int jarg3) {
  unsigned int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  int32_t arg3 ;
  bool result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (int32_t)jarg3;
  result = (bool)(arg1)->setInt32((std::string const &)*arg2,arg3);
  jresult = result;
  return jresult;
}


SWIGEXPORT float D_Config_getFloat(void * jarg1, char * jarg2) {
  float jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  float result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = (float)((Leap::Config const *)arg1)->getFloat((std::string const &)*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Config_setFloat(void * jarg1, char * jarg2, float jarg3) {
  unsigned int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  float arg3 ;
  bool result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  arg3 = (float)jarg3;
  result = (bool)(arg1)->setFloat((std::string const &)*arg2,arg3);
  jresult = result;
  return jresult;
}


SWIGEXPORT char * D_Config_getString(void * jarg1, char * jarg2) {
  char * jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  result = ((Leap::Config const *)arg1)->getString((std::string const &)*arg2);
  jresult = SWIG_d_string_callback((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT unsigned int D_Config_setString(void * jarg1, char * jarg2, char * jarg3) {
  unsigned int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  bool result;
  
  arg1 = (Leap::Config *)jarg1;
  if (!jarg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg2_str(jarg2);
  arg2 = &arg2_str; 
  if (!jarg3) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "null string");
    return 0;
  }
  std::string arg3_str(jarg3);
  arg3 = &arg3_str; 
  result = (bool)(arg1)->setString((std::string const &)*arg2,(std::string const &)*arg3);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Config_save(void * jarg1) {
  unsigned int jresult ;
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  bool result;
  
  arg1 = (Leap::Config *)jarg1;
  result = (bool)(arg1)->save();
  jresult = result;
  return jresult;
}


SWIGEXPORT void D_delete_Config(void * jarg1) {
  Leap::Config *arg1 = (Leap::Config *) 0 ;
  
  arg1 = (Leap::Config *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Controller__SWIG_0() {
  void * jresult ;
  Leap::Controller *result = 0 ;
  
  result = (Leap::Controller *)new Leap::Controller();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_Controller(void * jarg1) {
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  
  arg1 = (Leap::Controller *)jarg1;
  delete arg1;
}


SWIGEXPORT void * D_new_Controller__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Listener *arg1 = 0 ;
  Leap::Controller *result = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  if (!arg1) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Listener & type is null");
    return 0;
  } 
  result = (Leap::Controller *)new Leap::Controller(*arg1);
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT unsigned int D_Controller_isConnected(void * jarg1) {
  unsigned int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  bool result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = (bool)((Leap::Controller const *)arg1)->isConnected();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Controller_isServiceConnected(void * jarg1) {
  unsigned int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  bool result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = (bool)((Leap::Controller const *)arg1)->isServiceConnected();
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Controller_hasFocus(void * jarg1) {
  unsigned int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  bool result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = (bool)((Leap::Controller const *)arg1)->hasFocus();
  jresult = result;
  return jresult;
}


SWIGEXPORT int D_Controller_policyFlags(void * jarg1) {
  int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Controller::PolicyFlag result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = (Leap::Controller::PolicyFlag)((Leap::Controller const *)arg1)->policyFlags();
  jresult = (int)result; 
  return jresult;
}


SWIGEXPORT void D_Controller_setPolicyFlags(void * jarg1, int jarg2) {
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Controller::PolicyFlag arg2 ;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Controller::PolicyFlag)jarg2; 
  ((Leap::Controller const *)arg1)->setPolicyFlags(arg2);
}


SWIGEXPORT void D_Controller_setPolicy(void * jarg1, int jarg2) {
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Controller::PolicyFlag arg2 ;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Controller::PolicyFlag)jarg2; 
  ((Leap::Controller const *)arg1)->setPolicy(arg2);
}


SWIGEXPORT void D_Controller_clearPolicy(void * jarg1, int jarg2) {
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Controller::PolicyFlag arg2 ;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Controller::PolicyFlag)jarg2; 
  ((Leap::Controller const *)arg1)->clearPolicy(arg2);
}


SWIGEXPORT unsigned int D_Controller_isPolicySet(void * jarg1, int jarg2) {
  unsigned int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Controller::PolicyFlag arg2 ;
  bool result;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Controller::PolicyFlag)jarg2; 
  result = (bool)((Leap::Controller const *)arg1)->isPolicySet(arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Controller_addListener(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Listener *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Listener *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Listener & type is null");
    return 0;
  } 
  result = (bool)(arg1)->addListener(*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT unsigned int D_Controller_removeListener(void * jarg1, void * jarg2) {
  unsigned int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Listener *arg2 = 0 ;
  bool result;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Listener *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Listener & type is null");
    return 0;
  } 
  result = (bool)(arg1)->removeListener(*arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Controller_frame__SWIG_0(void * jarg1, int jarg2) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  int arg2 ;
  SwigValueWrapper< Leap::Frame > result;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (int)jarg2;
  result = ((Leap::Controller const *)arg1)->frame(arg2);
  jresult = new Leap::Frame((const Leap::Frame &)result); 
  return jresult;
}


SWIGEXPORT void * D_Controller_frame__SWIG_1(void * jarg1) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  SwigValueWrapper< Leap::Frame > result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = ((Leap::Controller const *)arg1)->frame();
  jresult = new Leap::Frame((const Leap::Frame &)result); 
  return jresult;
}


SWIGEXPORT void * D_Controller_images(void * jarg1) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  SwigValueWrapper< Leap::ImageList > result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = ((Leap::Controller const *)arg1)->images();
  jresult = new Leap::ImageList((const Leap::ImageList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Controller_config(void * jarg1) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  SwigValueWrapper< Leap::Config > result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = ((Leap::Controller const *)arg1)->config();
  jresult = new Leap::Config((const Leap::Config &)result); 
  return jresult;
}


SWIGEXPORT void * D_Controller_devices(void * jarg1) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  SwigValueWrapper< Leap::DeviceList > result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = ((Leap::Controller const *)arg1)->devices();
  jresult = new Leap::DeviceList((const Leap::DeviceList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Controller_locatedScreens(void * jarg1) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  SwigValueWrapper< Leap::ScreenList > result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = ((Leap::Controller const *)arg1)->locatedScreens();
  jresult = new Leap::ScreenList((const Leap::ScreenList &)result); 
  return jresult;
}


SWIGEXPORT void * D_Controller_bugReport(void * jarg1) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  SwigValueWrapper< Leap::BugReport > result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = ((Leap::Controller const *)arg1)->bugReport();
  jresult = new Leap::BugReport((const Leap::BugReport &)result); 
  return jresult;
}


SWIGEXPORT void D_Controller_enableGesture__SWIG_0(void * jarg1, int jarg2, unsigned int jarg3) {
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Gesture::Type arg2 ;
  bool arg3 ;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Gesture::Type)jarg2; 
  arg3 = jarg3 ? true : false;
  ((Leap::Controller const *)arg1)->enableGesture(arg2,arg3);
}


SWIGEXPORT void D_Controller_enableGesture__SWIG_1(void * jarg1, int jarg2) {
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Gesture::Type arg2 ;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Gesture::Type)jarg2; 
  ((Leap::Controller const *)arg1)->enableGesture(arg2);
}


SWIGEXPORT unsigned int D_Controller_isGestureEnabled(void * jarg1, int jarg2) {
  unsigned int jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  Leap::Gesture::Type arg2 ;
  bool result;
  
  arg1 = (Leap::Controller *)jarg1;
  arg2 = (Leap::Gesture::Type)jarg2; 
  result = (bool)((Leap::Controller const *)arg1)->isGestureEnabled(arg2);
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_Controller_trackedQuad(void * jarg1) {
  void * jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  SwigValueWrapper< Leap::TrackedQuad > result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = ((Leap::Controller const *)arg1)->trackedQuad();
  jresult = new Leap::TrackedQuad((const Leap::TrackedQuad &)result); 
  return jresult;
}


SWIGEXPORT long long D_Controller_now(void * jarg1) {
  long long jresult ;
  Leap::Controller *arg1 = (Leap::Controller *) 0 ;
  int64_t result;
  
  arg1 = (Leap::Controller *)jarg1;
  result = (int64_t)((Leap::Controller const *)arg1)->now();
  jresult = result;
  return jresult;
}


SWIGEXPORT void * D_new_Listener() {
  void * jresult ;
  Leap::Listener *result = 0 ;
  
  result = (Leap::Listener *)new SwigDirector_Listener();
  jresult = (void *)result;
  return jresult;
}


SWIGEXPORT void D_delete_Listener(void * jarg1) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  delete arg1;
}


SWIGEXPORT void D_Listener_onInit(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onInit((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onInitSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onInit((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onConnect(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onConnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onConnectSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onConnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onDisconnect(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onDisconnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onDisconnectSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onDisconnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onExit(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onExit((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onExitSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onExit((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onFrame(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onFrame((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onFrameSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onFrame((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onFocusGained(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onFocusGained((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onFocusGainedSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onFocusGained((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onFocusLost(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onFocusLost((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onFocusLostSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onFocusLost((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onServiceConnect(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onServiceConnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onServiceConnectSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onServiceConnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onServiceDisconnect(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onServiceDisconnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onServiceDisconnectSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onServiceDisconnect((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onDeviceChange(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onDeviceChange((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onDeviceChangeSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onDeviceChange((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onImages(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->onImages((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_onImagesSwigExplicitListener(void * jarg1, void * jarg2) {
  Leap::Listener *arg1 = (Leap::Listener *) 0 ;
  Leap::Controller *arg2 = 0 ;
  
  arg1 = (Leap::Listener *)jarg1;
  arg2 = (Leap::Controller *)jarg2;
  if (!arg2) {
    SWIG_DSetPendingException(SWIG_DIllegalArgumentException, "Leap::Controller const & type is null");
    return ;
  } 
  (arg1)->Leap::Listener::onImages((Leap::Controller const &)*arg2);
}


SWIGEXPORT void D_Listener_director_connect(void *objarg, void *dobj, SwigDirector_Listener::SWIG_Callback0_t callback0, SwigDirector_Listener::SWIG_Callback1_t callback1, SwigDirector_Listener::SWIG_Callback2_t callback2, SwigDirector_Listener::SWIG_Callback3_t callback3, SwigDirector_Listener::SWIG_Callback4_t callback4, SwigDirector_Listener::SWIG_Callback5_t callback5, SwigDirector_Listener::SWIG_Callback6_t callback6, SwigDirector_Listener::SWIG_Callback7_t callback7, SwigDirector_Listener::SWIG_Callback8_t callback8, SwigDirector_Listener::SWIG_Callback9_t callback9, SwigDirector_Listener::SWIG_Callback10_t callback10) {
  Leap::Listener *obj = (Leap::Listener *)objarg;
  SwigDirector_Listener *director = dynamic_cast<SwigDirector_Listener *>(obj);
  if (director) {
    director->swig_connect_director(dobj, callback0, callback1, callback2, callback3, callback4, callback5, callback6, callback7, callback8, callback9, callback10);
  }
}


SWIGEXPORT Leap::Interface * D_Pointable_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Arm_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Bone_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Pointable * D_Finger_Upcast(Leap::Pointable *objectRef) {
    return (Leap::Pointable *)objectRef;
}

SWIGEXPORT Leap::Pointable * D_Tool_Upcast(Leap::Pointable *objectRef) {
    return (Leap::Pointable *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Hand_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Gesture_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Gesture * D_SwipeGesture_Upcast(Leap::Gesture *objectRef) {
    return (Leap::Gesture *)objectRef;
}

SWIGEXPORT Leap::Gesture * D_CircleGesture_Upcast(Leap::Gesture *objectRef) {
    return (Leap::Gesture *)objectRef;
}

SWIGEXPORT Leap::Gesture * D_ScreenTapGesture_Upcast(Leap::Gesture *objectRef) {
    return (Leap::Gesture *)objectRef;
}

SWIGEXPORT Leap::Gesture * D_KeyTapGesture_Upcast(Leap::Gesture *objectRef) {
    return (Leap::Gesture *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Screen_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Device_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Image_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Mask_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_PointableList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_FingerList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_ToolList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_HandList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_GestureList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_ScreenList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_DeviceList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_ImageList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_TrackedQuad_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_MaskList_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_InteractionBox_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Frame_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_BugReport_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Config_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

SWIGEXPORT Leap::Interface * D_Controller_Upcast(Leap::Interface *objectRef) {
    return (Leap::Interface *)objectRef;
}

#ifdef __cplusplus
}
#endif

